---
title: let和const
date: 2020-08-28 15:48:33
permalink: /pages/ad78a3/
categories: 
  - 前端三件套
  - ES6文章
tags: 
  - ES6
---

ES6新增变量声明方式

<!-- more -->

## let命令

- 块级作用域

- 不存在变量提升
  
- 暂时性死区：在代码块内，使用`let`命令声明变量之前，该变量都是不可用的（即使代码块父级作用域已经定义）。  

- 不允许重复声明：`let`命令不允许在相同作用域内，重复声明同一个变量。


## const命令


## 块级作用域

### 为什么需要块级作用域

ES5只有全局作用域和函数作用域，没有块级作用域，所以有很多不合理的场景

1. 内层变量可能会覆盖外层变量

``` js
// 由于变量提升的原因导致内层的tmp覆盖了外层的tmp
var tmp = new Date();

function f() {
  console.log(tmp);
  if (false) {
    var tmp = 'hello world';
  }
}

f(); // undefined
```

2. 用于计数的循环变量泄露为全局变量

``` js
// 变量i只用来控制循环，但循环结束后它并没有消失，而泄露成了全局变量；
var s = 'hello';

for (var i = 0; i < s.length; i++) {
  console.log(s[i]);
}

console.log(i); // 5
```

### ES6的块级作用域

`let`和`const`实际上为JavaScript新增了块级作用域。

ES6允许块级作用域任意嵌套。每一层都是一个单独的作用域，外层作用域无法读取内层作用域的变量。块级作用域的出现实际上取代了匿名立即执行函数表达式。

``` js
{{{{
  {let insane = 'Hello World'}
  console.log(insane); // 报错
}}}};
```

### 块级作用域与函数声明

ES5中规定函数只能在顶层作用域和函数作用域中声明，不能在块级作用域声明。但浏览器为了兼容以前的代码，还是在支持在块级作用域之中声明函数。

ES6中引入了块级作用域，明确允许在块级作用域中声明函数。块级作用域中，函数声明语句的行为类似`let`，在块级作用域之外不可引用。

::: warning 注意
如果改变了块级作用域内声明的函数的处理规则，会对老代码产生很大的影响。为了减轻因此产生的不兼容问题，ES6规定，浏览器的实现可不遵守上面的规定，有自己的行为方式：

- 允许在块级作用域内声明函数

- 函数声明方式类似`var`，即会提升到全局作用域或函数作用域头部

:::

考虑到环境导致的行为差异太大，所以应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。

::: warning 注意
ES6块级作用域必须要有大括号，如果没有大括号，JavaScript引擎就认为不存在块级作用域。
:::

严格模式下，`let`、`const`、`function`，都只能声明在当前作用域的顶层。

``` js
// 第一种写法，报错
if (true) let x = 1;

// 第二种写法，不报错
if (true) {
  let x = 1;
}
```
``` js
// 不报错
'use strict';
if (true) {
  function f() {}
}

// 报错
'use strict';
if (true)
  function f() {}
```






## 综上

ES6 规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在 ES5 是很常见的，现在有了这种规定，避免此类错误就很容易了。

总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。


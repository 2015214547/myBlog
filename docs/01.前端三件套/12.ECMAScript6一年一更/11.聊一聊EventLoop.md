---
title: 聊一聊EventLoop
date: 2020-10-09 16:11:58
permalink: /pages/cbc9aa/
categories: 
  - 前端三件套
  - ES6文章
tags: 
  - ES6
---

有些东西，并不是越浓越好，要恰到好处。深深的话，我们浅浅的说，长长的路，我们慢慢的走。

<!-- more -->

## 什么是Event Loop？

顾名思义：事件循环

> 定义："Event Loop是一个程序结构，用于等待和发送消息和事件

Event Loop是指计算机系统的一种运行机制；JavaScript就采用这种机制来解决单线程带来的一些问题。

要了解Event Loop，首先要知道程序的运行模式。运行起来的程序叫做进程，一般一个进程一次只能执行一个任务。如果有很多任务需要执行，则无外乎以下三种解决办法

::: warning 
1. 排队，因为一个进程一次只能执行一个任务，所以只能等前面的任务执行完毕，再执行后面的任务
2. 新建进程，使用fork命令，为每个任务新建一个进程。
3. 新建线程，因为进程太耗费资源，所以现在的程序往往允许一个进程包含多个线程，由线程去完成任务。
:::


## 为什么JavaScript为单线程

所谓单线程就是指程序在同一时间只能干一件事情，那JavaScript为什么不设计为多线程呢？

这与JavaScript的用途有关，因为JavaScript设计之初是作为浏览器脚本语言而存在的，它的主要用途在于与用户交互及操作DOM，这就决定了它必须是单线程，因为如果是多线程就明显会带来很多复杂的同步问题。

例如：假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？

所以，为了避免程序设计的复杂性，JavaScript从诞生之日起就明确为单线程语言，这一特性以后也不会改变。


## 任务队列

单线程就意味着，它的所有任务都是在一个线程上进行完成，也就是说JavaScript执行任务时，需要按照排队原则进行任务处理，一旦遇到大量任务或者耗时任务时，JavaScript就会处于假死状态，无法响应用户的行为。

如果排队是因为计算量大，CPU忙不过来，倒也算了，但是很多时候CPU是闲着的，因为IO设备（输入输出设备）很慢（比如Ajax操作从网络读取数据），不得不等着结果出来，再往下执行。

显然这是有问题的，主线程完全可以不用管I/O设备，挂起处于等待中的任务，先运行后面的任务，等I/O设备返回了结构，再回头将挂起的任务执行完成。

所以基于这样的一个思想，JavaScript的语言设计就将所有的任务分为了两类：

1. 同步任务：在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；
2. 异步任务：这类任务不进入主线程，而进入任务队列，只有任务队列通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行；

::: warning 异步执行具体机制如下：
1. 所有同步任务都在主线程上执行，形成一个执行栈；
2. 主线程之外还有一个任务队列，只要异步任务有了运行结果，就在任务队列中放置一个事件；
3. 一旦执行栈中的所有同步任务执行完成之后，系统就会自动读取任务队列，看里面有哪些事件，找到这些事件对应的异步操作，结束它们的等待状态，进入执行栈，开始执行；
4. 主线程会不断的重复这个以上三步操作；
:::

只要主线程空了，就会去读取任务队列，这就是JavaScript的运行机制，这个过程是不断重复的；

## 事件和回调函数

任务队列是一个事件队列（也可以理解为消息队列），当I/O设备完成一项任务之后，就会在任务队列中添加一个事件，标记表示相关的异步操作可以进入执行栈执行。这样当主线程读取到任务队列时，就可从这些事件中获知可继续执行的异步任务。

"任务队列"中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等）。只要指定过回调函数，这些事件发生时就会进入"任务队列"，等待主线程读取。

所谓回调函数就是被主线程挂起来的代码，异步任务必须指定回调函数，当主线程开始执行异步任务时，就是执行对应的回调函数；

任务队列是一个先进先出的数据结构（队列），排在前面的事件，会优先被主线程读取。主线程的读取是自动，只要执行栈一清空，任务队列的第一位事件就自动进入主线程。由于存在定时器的功能，所以主线程会先检查执行时间，对于有的事件只有到了规定的时间才返回主线程进行执行。


## Event Loop

主线程从任务队列读取事件这个过程是不断循环的，所以整个这种运行机制即为Event Loop(事件循环)

主线程运行的时候，产生堆（heap）和栈（stack），栈中的代码调用各种外部API，它们在"任务队列"中加入各种事件（click，load，done）。只要栈中的代码执行完毕，主线程就会去读取"任务队列"，依次执行那些事件所对应的回调函数。


## 定时器

JavaScript中定时器功能主要由setTimeout()和setInterval()这两个函数来完成，它们的内部运行机制完全一样，区别在于前者指定的代码是一次性执行，后者则为反复执行。以下主要讨论setTimeout()。

任务队列除了放置异步任务的事件，还可以放置定时事件。

setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，也就是说，尽可能早得执行。它在"任务队列"的尾部添加一个事件，因此要等到同步任务和"任务队列"现有的事件都处理完，才会得到执行。

需要注意的是，setTimeout()只是将事件插入了"任务队列"，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证，回调函数一定会在setTimeout()指定的时间执行。


















## 参考： 

[什么是 Event Loop？](http://www.ruanyifeng.com/blog/2013/10/event_loop.html)

[Event Loop](http://www.ruanyifeng.com/blog/2014/10/event-loop.html)
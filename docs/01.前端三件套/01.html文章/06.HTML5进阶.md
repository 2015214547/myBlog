---
title: HTML5进阶
date: 2020-07-27 14:18:44
permalink: /pages/17bef7/
categories: 
  - 前端三件套
  - html文章
tags: 
  - html
---
# # 6. HTML5进阶

## 6.1 多媒体相关API

### （1）多媒体元素标签

#### **（1）`<video>`**

```html
<video>元素用来定义视频；</video>
```

#### （2）`<audio>`

``` html
<audio>元素用来定义音频</audio>
```

#### （3）`<embed />`

​	`<embed>`元素用来插入各种多媒体，格式可以是Midi、Wav、AIFF、AU、MP3等

#### （4）`<source>`

​	`<source>`标签为媒介元素（`<audio><video>`）定义媒介资源，`<source>`标签允许规定可替换的视频/音频文件供浏览器根据它对媒体类型或者编解码器的支持进行选择。

它的属性：

| **属性**  | **描述**                                       |
| --------- | ---------------------------------------------- |
| **src**   | 规定媒体文件的url                              |
| **type**  | 可选属性，最好不要省略。规定媒体资源的MIME类型 |
| **media** | 规定媒体资源的类型                             |



### （2）多媒体元素属性

``` html
<video>元素是H5新增元素，用于电影文件、其他视频流的播放；</video>
<audio>元素是H5新增元素，用于音乐文件，其他音频流的播放。</audio>
```

两个多媒体元素的开始标记与结束标记之间放置文本内容，可以在不支持该元素的浏览器中使用，那么将显示开始于结束标记之间的文本内容。

``` html
    <video id="vdoMain" src="video/Bootstrap全局样式.mp4" autoplay="true" width="700px" controls="controls"
        poster="images/Hbuilder.png" onProgress="Video_Progress(this)">
        您的浏览器不支持视频
    </video>
```

#### （1）video标签独有属性

##### （1）width/height属性

表示设置媒体元素的宽/高，单位是像素。如果不设置该属性，则使用播放源文件的大小。如果仅设置一个宽度或高度，则会根据播放源文件的长宽比例自动生成一个与之对应的高度或宽度值，即以等比例方式控制文件的大小；

##### （2）poster属性

poster属性值为所选图片的URL，如果添加该属性，将在视频文件播放前显示该图片，而不是默认显示视频文件的第一帧。另外，如果添加该属性，还可以避免在播放的视频文件不可用时，出现一片空白区域，影响用户体验。

``` html
<video src="kecheng.mp4" poster="tianlongbabu.jpg"></video>
```

#### （2）video、audio标签共有属性

##### （1）src属性

用于放置视频/音频文件的URL地址；src=” url”

##### （2）controls属性

该属性值为布尔值。如果将属性值设置为true或controls，则将在视频元素`<video>`的底部展示一个元素自带的控制条工具（一个播放/暂停控件、一个进度条和音量开关）。如果没有设置该属性，页面将不会显示任何效果；

##### （3）loop属性

loop属性表示媒体文件在线播放结束后是否还要进行循环播放，一旦添加该属性名称或将该属性值设为true，播放过程将不断重复，直到手动停止。Loop也可以自定义播放次数：loop=2就是循环播放两次；loop=-1无限循环播放；

##### （4）autoplay属性

autoplay属性可以使多媒体元素加载完成播放的文件后，实现自动播放的功能。

添加时，可以单独加入该属性名称，或者将属性值设为true都可；

##### （5）volume属性

volume属性表示媒体元素播放时的音量。该属性的取值范围为0-1，可在取值范围内修改该属性值，进而调节音量大小。

##### （6）muted属性

muted属性是一个布尔值，表示是否设置为静音，如果值为true，表示是静音。默认值为false。

``` html
    <video id="vdoMain" src="video/Bootstrap全局样式.mp4" autoplay="true" width="700px" controls="controls" poster="images/Hbuilder.png">您的浏览器不支持视频</video>
    <input type="button" id="btnVolume" value="调节音量" onClick="btnVolume_click();" />
    <input type="checkbox" id="chkMuted" onChange="chkMuted_change(this);" />开启静音
    <script>
        function $$(id) {
            return document.getElementById(id);
        }

        function btnVolume_click() {
            $$("vdoMain").volume = 0;
        }

        function chkMuted_change(e) {
            $$("vdoMain").muted = (e.checked) ? true : false;
        }
    </script>
```

##### （7）played属性

只读属性。通过多媒体元素中的played属性可以获取媒体文件已播放完成的时间段。Played属性返回一个TimeRanges对象，通过该对象可以获取已播放文件的开始时间和结束时间。

##### （8）paused属性

只读属性。paused属性可以返回当前播放文件是否出于暂停状态，该返回值为布尔值，如果为true，则表示文件处于暂停状态，否则为等待播放或正在播放状态。

##### （9）ended属性

只读属性。ended属性可以返回当前播放的文件是否已经结束，该返回值是一个布尔值，如果为true，表示当前播放的文件已结束。否则还没有结束。三个属性都为只读属性，不可进行修改，只能在事件中获取。

``` html
    <video id="vdoMain" src="video/Bootstrap全局样式.mp4" autoplay="autoplay" onPlaying="playing(this)" controls
        poster="images/Hbuilder.png"></video>

    <script>
        function playing(e) {
            alert(e.ended);
            alert(e.paused);
            alert(e.played);
        }
    </script>
```

##### （10）preload属性

Preload属性表示在页面打开时，多媒体元素是否需要将指定的媒体文件进行预加载。

注意： preload与autoplay相冲，设置了autoplay属性，那么preload属性就会失效。该属性有3个可选值：

| **属性值** | **描述**                                                     |
| ---------- | ------------------------------------------------------------ |
| none       | 表示不进行先期播放文件的加载                                 |
| Metadata   | 表示只加载播放文件基本信息（如总字节数、持续时间、第一帧信息等） |
| auto       | 表示需要将播放文件进行预加载，默认为“auto”                   |

``` html
<video id="vdoMain" src="video/Bootstrap全局样式.mp4" autoplay="autoplay" preload=auto loop=2 controls poster="images/Hbuilder.png"></video>  
```

##### （11）currentTime属性

currentTime属性可以返回媒体文件当前播放位置，也可以修改该属性来修改当前播放位置。如果修改成功，当前播放位置就指向所修改的时间，该属性为可读写属性。

##### （12）startTime属性

startTime属性可以返回多媒体元素开始播放的时间，默认情况下，该时间为0.该属性为只读属性，不可以修改。

##### （13）duration属性

duration属性可以返回多媒体元素总体播放时间。在加载文件过程中，该值将不断变化，如果加载完成，将返回播放整个文件所需的总时间。三个属性值的单位都为秒，使用过程中通常需要转成分钟，以便在页面中展示。

``` js
        function progress(e) {
            var strCurrTime = RuleTime(Math.floor(e.currentTime / 60), 2) + ":" + RuleTime(Math.floor(e.currentTime %
                60), 2);
            //获取当前分钟数和当前秒数				
            alert(strCurrTime);
        }
        //转换时间显示格式
        function RuleTime(num, n) {
            var len = num.toString().length;
            while (len < n) {
                num = "0" + num;
                len++;
            }
            return num;
        }
```

##### （14）error属性

Error属性是一个只读属性，在使用多媒体元素加载或读取文件过程中，如果出现异常或错误，将触发元素的**error事件**，在该事件中，通过元素的error属性返回一个MediaError对象，根据对象的code返回当前的错误值。MediaError对象中code对应四个返回值：

| **字符常量**                | **返回值** | **描述**                                                     |
| --------------------------- | ---------- | ------------------------------------------------------------ |
| MEDIA_ERR_ABORTED           | 1          | 媒体数据的下载过程由于用户的操作原因而被终止                 |
| MEDIA_ERR_NETWORK           | 2          | 确认媒体资源可用，但在下载时出现网络错误，媒体数据的下载过程被中止。 |
| MEDIA_ERR_DECODE            | 3          | 确认媒体资源可用，但是解码时发生错误                         |
| MEDIA_ERR_SRC_NOT_SUPPORTED | 4          | 媒体资源不可用或媒体格式不被支持                             |
|                             |            |                                                              |



##### （15）networkState属性

多媒体元素的networkState属性可以返回文件的网络状态。当浏览器读取媒体文件时，将触发一个**progress事件**，通过该事件，可以获取媒体文件在被打开过程中各个不同阶段的网络状态值。

networkState属性为只读属性，该属性对应四个返回值，如下：

| **字符常量**      | **返回值** | **描述**                                         |
| ----------------- | ---------- | ------------------------------------------------ |
| NETWORK_EMPTY     | 0          | 元素处于初始化状态                               |
| NETWORK_IDLE      | 1          | 浏览器已选择好播放的编码格式，但尚未建立网络连接 |
| NETWORK_LOADING   | 2          | 媒体数据正在加载过程中                           |
| NETWORK_NO_SOURCE | 3          | 没有支持的编码格式，不执行加载                   |
|                   |            |                                                  |

``` html
    <video src="kecheng.mov" poster="tianlongbabu.jpg" width="400px"></video>
    <script>
        var video = document.querySelector("video");
        video.addEventListener("error", function () {
            var error = video.error; //MediaError对象			
            switch (error.code) {
                case 1:
                    console.log("媒体数据的下载过程由于用户的操作原因而被终止");
                    break;
                case 2:
                    console.log("确认媒体资源可用，但在下载时出现网络错误，媒体数据的下载过程被中止。");
                    break;
                case 3:
                    console.log("确认媒体资源可用，但是解码时发生错误");
                    break;
                case 4:
                    console.log("媒体资源不可用或媒体格式不被支持");
                    break;
            }
        }, false)
    </script>
```

``` js
        function $$(id) {
            return document.getElementById(id);
        }

        function StrByNum(n) {
            switch (n) {
                case 0:
                    return "正在初始化……";
                case 1:
                    return "数据加载完成！";
                case 2:
                    return "正在加载中……";
                case 3:
                    return "数据加载失败！";
            }
        }

        function Video_Progress(e) {
            var intState = e.networkState;
            $$("spnStatus").style.display = "block";
            $$("spnStatus").innerHTML = StrByNum(intState);
            if (intState == 1) {
                $$("spnStatus").style.display = "none";
            }
        }
```

##### （16）readyState属性

该属性是只读属性，它返回媒体当前播放位置的就绪状态。属性值如下：

多媒体元素可以通过readyState属性返回当前播放文件的各种状态，根据这些状态，可以反映媒体文件在播放过程中是否正常。该属性为只读属性，共返回5种可能出现的状态值：

| **字符常量**      | **返回值** | **描述**                                                     |
| ----------------- | ---------- | ------------------------------------------------------------ |
| HAVE_NOTHING      | 0          | 没有获取到媒体的任何信息，当前播放位置没有可播放数据         |
| HAVE_METADATA     | 1          | 已经获取到了足够的媒体数据，但是当前播放位置没有有效的媒体数据。（即，获取的媒体数据无效，不能播放） |
| HAVE_CURRENT_DATA | 2          | 当前播放位置已经有数据可以播放，但是没有获取到可以让播放器前进的数据。 |
| HAVE_FUTURE_DATA  | 3          | 当前播放位置已经有数据可以播放，而且也获取到了可以让播放器前进的数据 |
| HAVE_ENOUGH_DATA  | 4          | 当前播放位置已经有数据可以播放，同时也获取到了可以让播放器前进的数据，而且浏览器确认媒体数据以某一种速度进行加载，可以保证足够的后续数据进行播放。 |
|                   |            |                                                              |

``` html
        <video id="vdoMain" src="Video/6-test_1.mov" onLoadStart="load_start(this);">

        <script>
            function load_start(e) {
                alert(e.readyState);
            }
        </script>
```

##### （17）currentSrc属性

​	该属性为只读属性，用于读取播放中的媒体数据的URL地址。

##### （18）buffered属性

​	该属性为只读属性。媒体元素的该属性可以用来返回一个对象，该对象实现TimeRanges接口，以确认浏览器是否已缓存媒体数据。

​	TimeRanges对象具有一个length属性，表示有多少个时间范围，大多数情况下存在时间范围，该值为1；不存在时间范围时，该值为0.

​	TimeRanges对象还有两个方法：

​	TimeRanges.start(index)、TimeRanges.end(index)，大多数情况下将index值设为0即可TimeRanges.start(0)表示当前缓存区内从媒体数据的什么时间开始进行缓存，TimeRanges.end(0)表示当前缓存区内的结束时间。

##### （19）seeking属性

​	只读属性。该属性表示浏览器是否正在请求某一特定播放位置的数据，属性值true表示浏览器正在请求数据，false表示浏览器已停止请求。

##### （20）seekable属性

​	只读属性。该属性可用来返回一个TimeRanges对象，该对象表示请求到的数据的时间范围。当媒体为视频时，开始时间为请求到的视频数据的第一帧的时间，结束时间为请求到的视频数据的最后一帧的时间。

##### （21）defaultPlaybackRate属性

defaultPlaybackRate属性可以返回页面媒体元素默认的文件播放速度频率，即默认播放速率。一般情况下，该属性值为1，也可以修改该属性值，从而改变其默认的播放速率值。（当前大部分浏览器还不支持修改这个属性值）

##### （22）playbackRate属性

playbackRate属性返回当前正在播放的媒体文件的速度频率，即当前播放速率。也可以修改该属性值，如果修改成功，将可以实现快进或慢进的播放效果，默认值为1；

（当前大部分浏览器还不支持修改这个属性值）

### （3）多媒体元素方法

多媒体元素可以通过controls属性显示控制条工具栏，单击工具栏中的按钮控制媒体文件的播放过程。也可以自定义播放按钮，调用多媒体元素在播放文件时的方法，实现控制文件播放过程的功能。

#### （1）play()

​	使用该方法来播放媒体，自动将元素的paused属性的值变为false。

#### （2）pause()

​	使用该方法来暂停播放，自动将元素的paused属性的值变为true。

#### （3）load()

​	使用该方法来重新载入媒体进行播放，自动将元素的playbackRate属性的值变为defaultPlaybackRate属性的值，自动将元素的error的值变为null。

#### （4）canPlayType()

​	使用该方法来测试浏览器是否支持指定的媒体类型。

​	语法： var support=videoElement.canPlayType(type);

​	参数： 字符串，与source元素的type属性的指定方法一样，用播放文件的MIME类型来指定，可以在指定的字符串中加上表示媒体编码格式的codes参数。	

​	返回值：

 （1）空字符串： 表示浏览器不支持此种媒体类型；

（2）maybe：表示浏览器可能支持此种媒体类型；

（3）probably：表示浏览器确定支持此种媒体类型。

``` js
        function ceshi() {
            var video = document.querySelector("video");
            var support = video.canPlayType("video/ogg");
            console.log(support); //maybe	
        }
```

``` html
    <video src="video/Bootstrap全局样式.mp4" width="700px" id="vdoMain" poster="images/Hbuilder.png"> </video>
    <p>
        <span onClick="v_load();">加载</span>
        <span id="spnPlay" onClick="v_play(this)"> 播放 </span>
    </p>
    <script>
        function $$(id) {
            return document.getElementById(id);
        }

        function v_load() {
            //点击加载按钮，调用load方法加载文件		
            $$("spnPlay").innerHTML = "播放";
            $$("vdoMain").load();
            //load方法加载媒体文件，直接调用即可。		
        }

        function v_play(e) {
            //点击播放/暂停按钮，如果在播放就暂停，在暂停就播放		
            if (e.innerHTML == "播放") {
                $$("vdoMain").play(); //调用play方法使播放文件暂停；		
                e.innerHTML = "暂停";
            } else {
                $$("vdoMain").pause(); //调用pause方法，使暂停文件播放		
                e.innerHTML = "播放";
            }
        }
    </script>
```

### （4）多媒体元素事件

多媒体元素有一系列完备的事件机制。

在媒体文件被浏览器请求加载、开始加载、开始播放、暂停播放、播放结束这一系列流程中所触发的事件，称为媒体播放事件，也是多媒体元素的核心事件。通过对这些事件的跟踪，可以很方便的获取媒体文件在各个阶段的播放状态。

​            ![img](https://qqadapt.qpic.cn/txdocpic/0/e6b9b489125fd37a40ac7b5586fb60c2/0?_type=png&w=643&h=427)            

​            ![img](https://qqadapt.qpic.cn/txdocpic/0/376c1dd0d60bd45c6107d67019eec341/0?_type=png&w=643&h=242)            



### （5）Web Audio API

#### （1）AudioContext对象

​	在Web Audio API中，使用AudioContext对象管理与播放声音。

​	为了生成一个声音，需要创建一个或多个声音源，并且通过AudioContext独享将这些声音源连接在一起。一个AudioContext对象可以支持多个音频输入，可以支持音频图的生成，所以在一个音频处理应用程序中，我们只需要创建一个AudioContext对象。在Web Audio API中，使用AudioBuffer对象加载音频数据。

``` js
var context=new webkitAudioContext();
```

## 6.2 画布相关API

在H5中新增了一个非常重要的元素——`<canvas>`。它是页面中的一块画布，可以在该画布上绘制任意形状图形（包括导入图片）；另外，借助该元素自带的API，通过编写Js代码，可以在`<canvas>`元素中控制各种图形，制作动画效果。

针对不支持HTML5的IE6、IE7、IE8，解决方法可以使用包含一个完整基于Canvas的JavaScript库，简称为ExCanvas。下载（地址：https://github.com/arv/ExplorerCanvas）并将其作为一个外部文件引用即可：

``` js
<!--[if It IE 9]><script src=’exCanvas.js’></script><![endif]-->
```

### （1）画布基础知识

想在页面中利用新增画布元素`<canvas>`绘画图像，需要经过三个步骤：

1. 使用`<canvas>`元素创建一个画布区域，并获取该元素；
2. 通过获取的`<canvas>`元素，取得该图形元素的上下文环境对象；
3. 根据取得的上下文环境对象，在页面中绘制图形或动画；

#### （1）`<canvas>`元素的基本用法

`<canvas>`元素只有两个可选属性，即width和height属性。没有src属性和alt属性，如果不给`<canvas>`元素设置宽高，则默认width=300px，height=150px；也可以使用CSS属性来设置宽高，但如果宽高属性和初始比例不一致时，会出现扭曲。建议永远不使用CSS属性来设置`<canvas>`的宽高；（行内属性方式设置宽高不能加单位px，这种方式修改的是元素自身大小。而样式表中修改Canvas标签宽高则是对它的内容进行缩放，如果其比例与Canvas本身比例不一致会导致图像扭曲）canvas默认透明。

​	较老版本的浏览器不支持`<canvas>`元素，因此`<canvas>`标签中间放置替换内容。支持`<canvas>`的浏览器只渲染`<canvas>`标签，不支持的浏览器则会之间渲染替代内容。

​	`<canvas></canvas>`的结束标签不能省，如果结束标签不存在，则文档的其余部分会被认为是替代内容，将不会显示出来。

``` html
<canvas id="tutorial" width="300" height="300">您的浏览器不支持画布元素   *//如果当前浏览器不支持canvas，则会显示标签中的内容*</canvas>
```

#### （2）渲染上下文

Canvas只是H5画布元素，本身是一个标签，不具备绘制功能，如果要绘制图形，首先要获取绘图环境，我们需要JavaScript提供的API来操作：

``` js
canvas.getContext('2d'); *//指定绘图类型为二维绘图，并通过这个方法返回一个环境对象，这个对象导出一个二维绘图API*
```

`<canvas>`元素会创建一个固定大小的画布，会公开一个或多个渲染上下文（画笔），使用渲染上下文来绘制和处理要展示的内容。重点研究2d渲染上下文；获取上下文环境对象“ctx”需要调用画布的getContext()方法，并向该方法传递一个字符串为“2d”的参数；一旦获得画布的上下文环境对象后，就可以使用该对象来使用绘图的方法和属性；

``` js
var canvas = document.getElementById('tutorial');
var ctx = canvas.getContext("2d");     //渲染上下文，获得2d上下文对象；
```

##### （1）绘图坐标及颜色填充

颜色填充：context.fillStyle=’ ’  *//可以是RGB、red、#类*

绘制边框：context.strokeStyle=’ ’ *//可以是RGB、red、#类*

矩形：cxt.fillRect(x,y,width,height)

canvas元素默认被网格覆盖，通常来说，网格中的一个单元相当于canvas元素的一个像素。所有元素的位置都相对于原点的位置来定位。其中参数x表示矩形起点到（0,0）x轴的距离，参数y表示矩形起点到（0,0）Y轴的距离，参数width表示矩形的宽度，参数height表示矩形的高度；绘制图形之前，需要设置图形的背景色。注意：设置绘制图形背景色的操作必须先于图形绘制，否则所设置的背景色将不起作用（或者可以不编写颜色填充代码，默认为黑色）

``` html
    <canvas id="tutorial" width="300" height="300">您的浏览器不支持画布元素</canvas>
    <script type="text/javascript">
        function draw() {
            var canvas = document.getElementById('tutorial');
            if (!canvas.getContext)
                return; //检验浏览器是否能够识别canvas； 
            var ctx = canvas.getContext("2d"); //渲染上下文；     
            ctx.fillStyle = "rgb(200,0,0)"; //绘制矩形之前需要设置图形的背景色      
            ctx.fillRect(10, 10, 55, 50); //绘制矩形  
        }
        draw();
    </script>
```

##### （2）绘制矩形

Canvas只支持一种原生的图形绘制：矩形。所有其他的图形绘制都至少需要生成一种路径（path），canvas提供了三种方法绘制矩形：

1. fillRect(x,y,width,height);  绘制一个填充的矩形；
2. strokeRect(x,y,width,height); 绘制一个矩形的边框；
3. clearRect(x,y,width,height);  清除指定的矩形区域，然后这块区域就会变得透明；

``` js
cxt.fillStyle="#CCCCCC";     //如果不编写颜色填充代码，则采用默认填充颜色  黑色；				
cxt.fillRect(50,50,100,100);  //绘制一个填充的矩阵；				
cxt.strokeStyle="red";   //注意与fillStyle书写的区别，两者填充的是不同的个体，不能混用；				
cxt.strokeRect(50,70,150,100); //绘制一个矩形边框；				
cxt.clearRect(60,60,30,30);   //清除指定的矩形区域，然后这块区域会变得完全透明；
```

这三个方法具有相同的参数，x，y，width，height数值可以不同，但代表的含义是相同的；

##### （3）绘制渐变图形

利用canvas元素可以绘制出有渐变色的图形。渐变的方式分为两种：线性渐变、径向渐变。

###### （1）线性渐变

1. 在获取上下文环境对象cxt之后，调用该对象的createLinearGradient()方法创建一个对象，将其命名为gnt；

**gnt=createLinearGradient(xstart,ystart,xEnd,yEnd)**

Xstart,ystart表示渐变色开始时的坐标；xEnd,yEnd表示渐变色借宿时的坐标，要使渐变色仅水平方向或竖直方向变化时，则将另一方向的Start与end设置相同数值即可；

1. 调用gnt对象的addColorStop()方法，进行渐变颜色与偏移量的设置。

**gnt.addColorStop(value,color);**

参数value表示渐变位置偏移量，他的取值在0到1之间；参数color表示渐变开始与结束时的颜色，分别于偏移量0,1对应；为了实现颜色渐变效果，需要调用两次该方法，一次表示开始渐变时的位置和颜色，一次表示结束渐变时的位置和颜色；

（3）通过gnt对象将偏移量与渐变色的值设置完成后，再将gnt对象赋值给fillStyle属性，表明此次图形的样式是一个渐变对象，最后使用fillRect()方法绘制出一个有渐变色的图形。

``` html
    <body onload="pageload();"> <canvas id="cnvMain" width="400px" height="300px"></canvas>
        <script>
            function $$(id) {
                return document.getElementById(id);
            }

            function pageload() {
                var cnv = $$("cnvMain");
                var cxt = cnv.getContext("2d");
                //绘制由左到右的颜色渐变图形；		
                var gnt1 = cxt.createLinearGradient(20, 20, 150, 20);
                //yStart与yEnd相等，只水平方向变化；		
                gnt1.addColorStop(0, "blue");
                //渐变颜色及偏移量的设置；0为开始时的位置，1为结束的位置；		
                gnt1.addColorStop(1, "#fff");
                cxt.fillStyle = gnt1;
                cxt.fillRect(20, 20, 150, 20); //绘制由上至下的颜色渐变图形；		
                var gnt2 = cxt.createLinearGradient(20, 20, 20, 150); //对应第一步		
                gnt2.addColorStop(0, "green"); //对应第二步		
                gnt2.addColorStop(1, "#fff");
                cxt.fillStyle = gnt2;
                //对应第三步；			
                cxt.fillRect(20, 20, 20, 150); //绘制沿对角线的颜色渐变图形；	
                var gnt3 = cxt.createLinearGradient(50, 50, 100, 100);
                gnt3.addColorStop(0, "red");
                gnt3.addColorStop(1, "#fff");
                cxt.fillStyle = gnt3;
                cxt.fillRect(50, 50, 100, 100);
            }
        </script>
    </body>
```

### （2）在画布中使用路径

在页面的画布元素中，调用绘画路径的两个方法moveTo()与lineTo()可以绘制直线，调用arc()方法可以绘制指定位置与大小的圆形。

#### （1）moveTo()与lineTo()的用法--直线绘制

moveTo()方法用于将画笔移至指定点，并以该点为直线的开始点，调用格式为：

cxt.moveTo(x,y);

x为起点的横坐标，y为起点的纵坐标。调用该方法后画布中即设置了一个绘制直线的开始点。

而如果是绘制直线，则还需要调用lineTo()方法，该方法将用画笔从指定的起点坐标与传递的终点坐标参数之间绘制一条直线，调用格式如下：

cxt.lineTo(x,y);

x为终点横坐标，y为终点纵坐标。该方法可以反复调用，第一次调用后，画笔自动移至终点坐标位置；第二次调用时，又以终点坐标位置作为第二次调用时的起点位置，开始绘制直线。当直线路径绘制完成后，再调用stroke()方法，在画布中描边直线路径，最终在画布中展示直线效果，该方法调用：cxt.stroke();该方法无参数，用于绘制玩路径后对路径进行描边处理；

``` js
        function $$(id) {
            return document.getElementById(id);
        }

        function pageload() {
            var cnv = $$("cnvMain");
            var cxt = cnv.getContext("2d");
            cxt.moveTo(20,
                150); //获取起点位置；		
            cxt.lineTo(100, 20); //第一条线；		
            cxt.lineTo(380, 150); //第二条线；	
            cxt.lineTo(300, 280); //第三条线；			
            cxt.lineTo(20, 150); //第四条线		
            cxt.lineWidth = 3; //设置直线的边框值；		
            cxt.strokeStyle = "red"; //调节描边的边框颜色，对颜色的设置要在描边之前，否则没有作用；		
            cxt.stroke(); //描边时默认为黑色，可以更换颜色；	
        }
```

#### （2）arc()方法--圆形绘制

使用上下文环境变量的arc()方法描绘圆形路径，以及绘制各种形状的圆形图案，该方法的调用格式如下：

``` js
cxt.arc(x,y,radius,startAngle,endAngle,anticlockwise);
```

x表示绘制圆形的横坐标，y表示绘制圆形的纵坐标；radius表示绘制圆的半径，startAngle的值为0，表示从0弧度开始；endAngle的值为Math.PI*2，表示到360弧度时结束。若要绘制半圆，则startAngle为0不变，endAngle变为Math.PI*1表示到180弧度时结束；参数anticlockwise是一个布尔值，表示是否按顺时针绘制，如果为true，则顺时针，如果为false则逆时针；

在调用arc()方法绘制圆形路径之前，需要调用上下文环境对象中的beginPath()方法，声明开始绘制路径，调用格式为：cxt.beginPath();该方法无参数。注意：在使用遍历或循环绘制路径时，每次都要调用该方法（即该方法仅对应单次的路径绘制）

在绘制圆形路径完成后，还要调用closePath()方法，将所绘制完成的路径进行关闭，调用格式：cxt.closePath(); 该方法与beginPath用法一样，无参数，只对应单次绘制；closePath方法与beginPath方法是成对出现的； 

圆形路径绘制完成后，并没有在画布元素中展示，因为上面的操作仅绘制了路径，还需要对路径进行描边或填充。

如果描边则调用stroke()方法，在调用该方法之前还可以设置边框的颜色和宽度；设置边框宽度与颜色的代码必须在描边代码之前，否则不起作用；

调用上下文环境对象的fill()方法可以进行填充操作。在调用填充操作之前，可以设置填充颜色；对于所绘制的圆形路径，可以既填充又描边。

``` js
        function pageload() {
            var cnv = $$("cnvMain");
            var cxt = cnv.getContext(
                "2d"); //开始画圆		
            cxt.beginPath();
            cxt.arc(300, 250, 200, 0, Math.PI * 2, true); //画圆		
            cxt.closePath(); //开始画描边	
            cxt.strokeStyle = "red"; //边框颜色			
            cxt.lineWidth = 3; //边框宽度直接写数值，不能带px单位；		
            cxt
                .stroke(); //描边，无参数直接调用			
            //开始填充		
            cxt.fillStyle = "#ccc"; //填充的颜色			
            cxt.fill(); //填充
            cxt.clearRect(0,0,350,500);  //	清除画布规定位置图形	
        }
```

#### （3）弧线绘制—arcTo()

arcTo()方法在画布上创建介于两个切线之间的弧或曲线。

​	语法：arcTo(x1,y1,x2,y2,r)  *//弧起点的**xy**坐标，终点的**xy**坐标以及弧的半径*

``` js
cobj.beginPath();				
cobj.moveTo(500,500);  *//创建一个开始点*				
cobj.arcTo(500,0,600,100,50);*//				
cobj.closePath();*    *//添加之后会闭合路径*				
cobj.lineWidth=3;				
cobj.strokeStyle='yellowgreen';				
cobj.stroke();
```

#### （4）绘制二次贝塞尔曲线

​	二次贝塞尔曲线需要两个点。第一个点用于二次贝塞尔计算中的控制点，第二个点是曲线的结束点。曲线的开始点是当前路径中最后一个点。如果路径不存在，则使用beginPath()和moveTo()方法来定义开始点。

​	语法：quadraticCurveTo(cpx,cpy,x,y)  //控制点xy坐标，结束点xy坐标

``` js
//绘制二次贝塞尔曲线				
cobj.beginPath();				
cobj.moveTo(600,20);  //创建开始点				
cobj.quadraticCurveTo(600,100,800,20);    //创建控制点和结束点				
cobj.lineWidth=3;				
cobj.strokeStyle='skyblue';				
cobj.stroke();
```

#### （5）绘制三次贝塞尔曲线

​	三次贝塞尔曲线需要三个点。前两个点用于三次贝塞尔计算中的控制点，第三个点是曲线的结束点。曲线的开始点是当前路径中的最后一个点。如果路径不存在，那么就使用beginPath()和moveTo()方法来定义开始点

​	语法：bezierCurveTo(cp1x,cp1y,cp2x,cp2y,x,y)  //两个控制点和一个结束点

``` js
//绘制三次贝塞尔曲线---椭圆				
cobj.beginPath();				
cobj.moveTo(700,300);				
cobj.bezierCurveTo(700,330,800,330,800,300);				
cobj.bezierCurveTo(800,270,700,270,700,300);				
cobj.lineWidth=2;				
cobj.strokeStyle='#F00';				
cobj.stroke();
```

#### **（6）绘制线性渐变**

​	context对象可以通过createLinearGradient()和createRadialGradient()两个方法创建渐变对象。

​	语法：createLinearGradient(x1,y1,x2,y2);  *//创建一个从（x1,y1）到（x2,y2）的线性渐变对象。*

​	渐变对象创建完成后必须使用它的addColorStop()方法来添加颜色

``` js
var grad=cobj.createLinearGradient(700,0,800,200);				
grad.addColorStop(0,'red');				
grad.addColorStop(0.3,'blue');				
grad.addColorStop(0.7,'yellow');				
grad.addColorStop(1,'#000');				
cobj.fillStyle=grad;				
cobj.fillRect(600,0,500,200);
```

#### （7）绘制渐变圆形--径向渐变

使用径向渐变的方式绘制有渐变色的圆形，需要调用上下文对象cxt中的createReadialGradient()方法，格式如下：

​	语法：createRadialGradient(x1,y1,r1,x2,y2,r2);  *//创建一个从（x1,y1）为圆心，r1为半径的圆到以（x2，y2）为圆心，以r2为半径的圆的径向渐变。*

调用该方法时，从开始渐变圆心的坐标位置向结束圆心的坐标位置进行颜色渐变，即两个圆之间通过各自的圆心坐标连接成一条直线，起点为开始圆心，终点为结束圆心，色彩由起点向终点进行扩散，直至终点圆外框。

使用createRadialGradient()方法仅新建了一个径向渐变的对象，接下来需要通过addColorStop()方法为该对象添加偏移量和渐变色，并将该对象设置为fillStyle的值。最后调用fill()方法，在画布中绘制出一个有径向渐变色彩的圆形。

``` js
        function $$(id) {
            return document.getElementById(id);
        }

        function pageload() {
            var cnv = $$("cnvMain");
            var cxt = cnv.getContext("2d"); //开始创建渐变对象；			
            var gnt1 = cxt.createRadialGradient(250, 250, 0, 350, 350, 400); //径向渐变	
            gnt1.addColorStop(0, "#000"); //添加偏移量和渐变色，可以分多段；		
            gnt1.addColorStop(0.3, "red");
            gnt1.addColorStop(0.5, "green");
            gnt1.addColorStop(0.7, "blue");
            gnt1.addColorStop(1, "#fff"); //开始绘制圆形路径；		
            cxt.beginPath();
            cxt.arc(350, 250, 200, 0, Math.PI * 2, true);
            cxt.closePath(); //将渐变颜色赋给填充对象实现渐变效果			
            cxt.fillStyle = gnt1;
            cxt.fill();
            //描边			
            cxt.strokeStyle = "red";
            cxt.lineWidth = 3;
            cxt.stroke();
        }
```

### （3）对画布中图形的操作

在使用画布元素`<canvas>`绘制图形时，有时需要对已绘制完成的图形进行相关的操作，如移动、缩放和旋转等，这些操作可以借助canvas API中提供的相关方法来实现。通过它里面提供的方法，可以将多块图形以不同的方式结合在一起展示，还可以通过增加阴影属性值，为图形添加不同方向的阴影效果等。

#### （1）变换图形原点坐标

Canvas API提供了三种处理变换图形原点坐标的方法：translate()、scale()、rotate()，通过调用这些方法可以实现对图形的移动、缩放和旋转。

**translate()方法调用格式**：cxt.translate(x,y);该方法的功能是实现对图形的移动操作，x表示将图形原点的横坐标移动的距离，大于0向右移，小于0向左移；y表示将图形原点纵坐标移动的距离，大于0向下移，小于0向上移。

**scale()方法的调用格式如下：**cxt.scale(x,y);该方法的功能是实现对图形的缩放操作。x表示横坐标方向缩放的倍数值，大于0放大，小于0缩小；y表示向纵坐标方向缩放的倍数值，大于0放大，小于0缩小；

**rotate()方法的调用格式：**cxt.rotate(angle);该方法的功能是实现对图像的旋转操作，angle表示图形旋转的角度，angle大于0顺时针旋转，小于0逆时针旋转；

``` js
        function spn1_click() {
            var cnv = $$("cnvMain");
            var cxt = cnv.getContext("2d");
            cxt.translate(-20, -20);
            pageload();
            //每次操作后都要重新调用自定义的绘制函数；		
            cxt.translate(40, 40);
            pageload();
        }

        function spn2_click() {
            var cnv = $$("cnvMain");
            var cxt = cnv.getContext("2d");
            cxt.scale(1.5, 0.5);
            pageload();
            cxt.scale(0.5, 1.5);
            pageload();
        }

        function spn3_click() {
            var cnv = $$("cnvMain");
            var cxt = cnv.getContext("2d");
            cxt.rotate(Math.PI / 8);
            pageload();
            cxt.rotate(-Math.PI / 4);
            pageload();
        }
```

#### （2）组合多个图形

如果在画布中绘制多个有交叉点的图形，在交叉之处新绘制的图形会覆盖原图形。如果想改变这种默认多图组合的显示方式，可以通过修改上下文环境对象的globalCompositeOperation属性值来实现，它的属性值如下：（source表示新图形资源；destination表示原图形资源）

| 属性值           | 描述                                                         |
| ---------------- | ------------------------------------------------------------ |
| Source-over      | 显示图像时，新绘制的图形覆盖原先绘制的图形，这是默认值       |
| Copy             | 只显示新图像，其他部分做透明处理                             |
| Darker           | 两种图形都显示，在图形重叠部分，颜色由两个图形的颜色值相减后形成 |
| Destination-atop | 只显示新图形中与原图形重叠部分，及新图形的其余部分，其他部分做透明处理 |
| Destination-in   | 只显示原图形中与新图形重叠部分，其他部分做透明处理           |
| Destination-out  | 只显示原图形中与新图形不重叠部分，其他部分做透明处理         |
| Destination-over | 与source-over相反，原先绘制的图形覆盖新绘制图形              |
| Lighter          | 两种图形都显示，在图形重叠部分，颜色由两个图形的颜色值相加后形成 |
| Source-atop      | 只显示原图形中与新图形重叠部分及原图形的其余部分，其他部分做透明处理 |
| Source-in        | 只显示新图形中与原图形重叠部分，其他部分做透明处理           |
| source-out       | 只显示新图形中与原图形不重叠部分，其他部分做透明处理         |
| Xor              | 两种图形都绘制，并透明处理图形重叠部分。                     |



#### （3）添加图像阴影

在使用画布元素`<canvas>`绘制图形时，可以为图形添加背景阴影，以达到立体显示的效果。实现这一功能，需要对上下文环境对象的阴影属性进行设置。图形阴影相关属性如下：

| 属性名称      | 描述                                                         |
| ------------- | ------------------------------------------------------------ |
| ShadowOffsetX | 阴影与图像的水平距离，大于0时向右移，小于0时向左移，默认为0  |
| ShadowOffsetY | 阴影与图形的垂直距离，大于0时向下偏移，小于0时向上偏移，默认为0； |
| ShadowColor   | 阴影颜色值；                                                 |
| ShadowBlur    | 阴影模糊值，值越大模糊越强，反之越弱，默认为1；（该项为可选项，不影响阴影效果的实现，需要设置时，值在1-10之间比较适宜） |



``` js
        function pageload() {
            var cnv = $$("cnvMain");
            var cxt = cnv.getContext("2d"); //添加阴影效果    先写阴影效果，再绘制图形；		
            cxt.shadowOffsetX = -6;
            cxt.shadowOffsetY = -6;
            cxt.shadowColor = "pink";
            cxt.shadowBlur = 2; //绘制图形		
            cxt.fillStyle = "deeppink";
            cxt.fillRect(200, 100, 200, 200);
            cxt.strokeStyle = "red";
            cxt.lineWidth = 2;
            cxt.strokeRect(200, 100, 200, 200);
        }
```

#### （4）**擦除Canvas画板**

语法：contextclearRect(x,y,width,height); *//要清除的矩形xy坐标及其宽高*

``` js
//清除整块画布；				
cobj.clearRect(0,0,$('canvas')[0].width,$('canvas')[0].height);
```

### （4）处理画布中的图像--image导入

在画布元素中，不仅可以绘制各种形状的图形，还可以通过canvasAPI中的方法将磁盘或网络中的图像导入到画布中，并对导入的图像进行平铺、切割，像素处理等多项操作。

#### （1）绘制图像--缩放

在画布元素中绘制图像需要调用上下文环境对象中的drawImage()方法，通过该方法可以将页面中存在的<img>元素，或通过JS创建的image对象绘制在画布上。该方法有三种调用方式：

``` js
cxt.drawImage(image,dx,dy);
```

Image表示页面中的图像，无论该图像时页面中的`<img>`元素，还是编写JS代码创建的image对象，都需要在绘制图像前完全加载该图像。dx表示图像左上角在画布中的横坐标，dy表示图像左上角在画布中的纵坐标。

``` js
cxt.drawImage(image,dx,dy,dw,dh);
```

dw表示原图像缩放至画布中的宽度，dh表示原图像缩放至画布中的高度。通过该方式可以将原图像按照指定大小绘制在画布规定位置上；

``` js
cxt.drawImage(image,sx,sy,sw,sh,dx,dy,dw,dh);
```

sx、sy、sw、sh表示原图像需要裁剪的范围；sx表示原图像被绘制部分的横坐标，sy表示原图像被绘制部分的纵坐标，sw表示原图像被绘制部分的宽度，sh表示原图像被绘制部分的高度。通过该方式可以将原图像指定的范围以映射的方式，绘制到画布中的指定区域。

``` js
        var intNum = 0;

        function cnvclick(cnv) {
            intNum += 1;
            intNum = (intNum == 4) ? 1 : intNum;
            var cxt = cnv.getContext("2d");
            cxt.clearRect(0, 0, cnv.width, cnv.height);
            var objImg = new Image();
            objImg.src = "images/图片.jpg";
            objImg.onload = function () {
                switch (intNum) {
                    case 1:
                        cxt.drawImage(objImg, 10, 10);
                        break;
                    case 2:
                        cxt.drawImage(objImg, 10, 10, 400, 300);
                        break;
                    case 3:
                        cxt.drawImage(objImg, 10, 10, 300, 200);
                        cxt.drawImage(objImg, 45, 50, 100, 150, 300, 200, 160, 180);
                        break;
                }
            }
        }
```

#### （2）平铺图像

通过调用上下文环境对象中的createPattern()方法关联图像元素。选择平铺方式，创建一个平铺对象，并将该平铺对象赋给fillStyle属性，最后通过调用fillRect()方法，将该平铺对象绘制在画布中，从而实现平铺效果。调用格式如下：

``` js
Cxt.createPattren(image,type);
```

Image表示被平铺的图像，type表示图像平铺的方式，该参数有四种取值：

| 名称      | 描述                           |
| --------- | ------------------------------ |
| no-repeat | 不平铺绘制的图像               |
| repeat-x  | 按水平方向横向平铺所绘制的图像 |
| repeat-y  | 按垂直方向纵向平铺所绘制的图像 |
| repeat    | 全方位平铺所绘制的图像         |

``` js
        var intNum = 0;

        function cnvclick(cnv) {
            intNum += 1;
            intNum = (intNum == 5) ? 1 : intNum;
            var strPrnType = "";
            switch (intNum) {
                case 1:
                    strPrnType = "no-repeat";
                    break;
                case 2:
                    strPrnType = "repeat-x";
                    break;
                case 3:
                    strPrnType = "repeat-y";
                    break;
                case 4:
                    strPrnType = "repeat";
            }
            var cxt = cnv.getContext("2d");
            cxt.clearRect(0, 0, cnv.width, cnv.height);
            //先清除页面上残留的图形		
            var objImg = new Image();
            objImg.src = "images/HBuilder.png";
            var prn = cxt.createPattern(objImg, strPrnType);
            objImg.onload = function () {
                //加载完成图片后执行函数			
                cxt.fillStyle = prn;
                //将平铺对象赋值给fillStyle属性；		
                cxt.fillRect(0, 0, cnv.width, cnv.height);
            }
        }
```

#### （3）切割图像

在画布元素中还可以调用上下文环境对象中的clip()方法切割在画布中绘制的图像，调用方法：cxt.clip();该方法是一个无参数方法，用于切割使用路径方式在画布中绘制的区域。在使用该方法之前必须使用路径方式在画布中绘制一个区域，然后才能通过调用clip()方法对该区域进行切割；

``` js
        function pageload() {
            var cnv = $$("cnvMain");
            var cxt = cnv.getContext("2d");
            var objImg = new Image();
            objImg.src = "images/图片.jpg";
            objImg.onload = function () {
                drawCirc(cxt, 60, true); //绘制大圈，进行切割		
                cxt.drawImage(objImg, 70, 30, 140, 140); //绘图，只导入不缩放			
                drawCirc(cxt, 10, false); //绘制小圈		
            }
        }

        function drawCirc(cxt, intR, blinC) {
            cxt.beginPath();
            cxt.arc(140, 95, intR, 0, Math.PI * 2, true);
            cxt.closePath();
            cxt.strokeStyle = "#666";
            cxt.lineWidth = 3;
            cxt.stroke(); //给圆形描边，无参数直接调用，，，绘制边框矩形
            cxt.strokeRect(x, y, width, height);
            if (blinC) {
                cxt.clip();
            } else {
                cxt.fillStyle = "#fff";
                cxt.fill();
            }
        }
```

#### （4）处理像素

在H5中调用canvas API中的方法还可以处理画布中绘制图形的像素，如做成蒙版效果、黑白效果等。要实现这样的页面效果，需要在加载图像时调用上下文环境对象的两种方法：getImageData()方法，用于获取图像中的像素；putImageData()方法，用于将处理后的像素重新绘制画布中。调用格式如下：

``` js
cxt.getImageData(sx,sy,sw,sh);
```

Sx为所选图像区域的横坐标，sy为所选图像区域的纵坐标，sw为所选图像区域的宽度，sh为所选图像区域的高度；获取的像素区域可以通过一个变量保存，如变量objImgData，该变量是一个canvasPixelArray对象，其中的data属性是一个用于保存像素数据的数组。objImgData.Data.Length为获取的像素总量。

``` js
cxt.putImageData(image,dx,dy);
```

Image表示重新绘制的图像，dx表示重新绘制图形在画布左上角的横坐标，dy表示重新绘制图像在画布左上角的纵坐标。

### （5）画布的其他应用

使用画布元素还可以调用canvas API中的相关方法绘制文字；还能将绘制的图形保存、还原、以base64位的URL形式在浏览器中输出，以及在画布中制作简单的动画。

#### （1）绘制文字

在画布中绘制文字可以调用上下文环境对象的fillText()与strokeText()方法，前者用于在画布中以填充的方式绘制文字，后者用于在画布中以描边的方式绘制文字。调用方法如下：

``` js
cxt.fillText(content,dx,dy,[maxWidth]);
cxt.strokeText(content,dx,dy,[maxWidth]);
```

content表示文字内容，dx表示绘制文字在画布左上角的横坐标，dy表示绘制文字在画布左上角的纵坐标，maxWidth为可选项表示绘制文字显示的最大长度，设置后，在该长度值范围内绘制文字；

在画布绘制文字时，除调用以上两种方法外，还要设置相关的属性，其中与绘制文字相关的属性如下：

| **属性**     | **描述**                                                     |
| ------------ | ------------------------------------------------------------ |
| font         | 设置CSS样式中字体的任何值，如字体样式、名称、大小、粗细、行距等； |
| textAlign    | 设置文本对其方式，取值start、end、left、right、center        |
| textBaseline | 设置文本相对于起点的位置，取值为top、bottom、middle          |

``` js
        var intNum = 0;

        function cnvclick(cnv) {
            intNum += 1;
            intNum = (intNum == 4) ? 1 : intNum;
            var cxt = cnv.getContext("2d");
            switch (intNum) {
                case 1:
                    drawText1(cxt, "bolder 45px '宋体'", 200, 150);
                    break;
                case 2:
                    drawText2(cxt, "bolder 55px '楷体'", 340, 250);
                    break;
                case 3:
                    drawText3(cxt, "bolder 65px '隶书'", 500, 350);
                    break;
            }
        }

        function drawText1(cxt, strFont, intX, intY) {
            cxt.font = strFont;
            cxt.textAlign = "center";
            cxt.Baseline = "bottom";
            cxt.strokeStyle = "deeppink";
            cxt.strokeText("喜欢", intX, intY);
            cxt.fillStyle = "#666";
            cxt.fillText("袁成成", intX, intY);
        }
```

#### （2）图片操作

#### （3）保存、恢复及输出图形

在H5中，有时需要在画布中绘制多个图形，并在图形之间进行切换，如果不能保存，那么切换之后，原先绘制的图形将丢失。通过调用上下文环境对象中的save()方法，保存已绘制的图形；当需要使用已绘制图形时，再通过调用restore()方法还原保存的图形，或者通过调用toDataURL()方法将保存的图形输出至浏览器中。三种方法调用格式如下：

cxt.save();该方法无参数，实现保存画布中图形的功能；

cxt.restore();该方法无参数，实现还原已保存图像的功能；

cxt.toDataURL(ImgType);用于实现将画布中的图形以base64位编码的方式输出至浏览器中，参数ImgType表示输出数据的MIME类型，如“image/png”等。

#### （4）制作简单的动画

1、自定义一个函数，用于图形的移动或其他动作。

2、使用setInterval()方法设置动画执行的间隔时间，反复执行自定义函数。

## 6.3 页面显示API

### （1）Page Visibility API

​	该API允许开发者知道Web页面在何时变为可见或获取焦点。在Page Visibility API中，当用户将Web页面最小化或将当前浏览器标签切换到其他标签时，将会触发一些事件，开发者可以指定在该事件中所需执行的处理。

​	该API的使用场合：

1. 一个应用程序具有多幅图片的幻灯片式的连续播放功能，当页面处于不可见状态时，图片停止播放；当页面可见时，图片恢复播放；
2. 一个实时显示服务器端信息的应用程序，当页面不可见状态时，停止定期向服务器端请求数据的处理；当页面可见时，继续执行定期向服务器端请求数据的处理；
3. 一个具有播放视频功能的应用程序，当页面不可见时，暂停播放；当页面可见时，恢复播放。

​	在Page Visibility API中，可以通过document对象的hidden属性值来判断页面是否处于可见状态，当页面处于可见状态时，属性值为false，当页面处于不可见状态时，属性值为true。

​	或者，在Page Visibility API中，可以通过document对象的visibilityState属性值来判断页面的可见状态。该属性值是一个字符串：

1. visible：页面内容部分可见，当前页面位于用户正在查看的浏览器标签窗口中，且浏览器窗口并未被最小化；
2. hidden：页面内容对用户不可见。当前页面不在用户正在查看的浏览器标签窗口中，或浏览器窗口已被最小化；
3. prerender：页面内容已被预渲染，但对用户不可见；

``` js
        function handle() {
            var video = $("video");
            if (document.hidden) {
                video.pause();
            } else {
                video.play();
            }
        }
        document.addEventListener("webkitvisibilitychange", handle, false);
```

### （2）Fullscreen API

​	该API的作用是将页面整体或页面中某个局部区域设为全屏显示状态。

#### （1）requestFullScreen()

​	在Fullscreen API中，可以通过DOM对象的某个节点对象的requestFullScreen()方法将页面或元素设定为全屏显示状态。

​            ![img](https://qqadapt.qpic.cn/txdocpic/0/2c08bc51ca9e2a3c443409a8213e7d8f/0?_type=png&w=486&h=198)            

#### **（2）exitFullscreen()/CanvelFullScreen()**

​	在Fullscreen API中，也可以通过DOM对象或某个元素的exitFullscreen()方法或CanvelFullScreen()方法将页面或某个元素设定为非全屏状态。在FullScreen API中，也可以通过DOM对象或某个元素的exitFullscreen属性值或CanvelFullScreen属性值来判断浏览器是否支持FullScreen API

​            ![img](https://qqadapt.qpic.cn/txdocpic/0/77f49178cd162bdbc1191bcf6810b5e0/0?_type=png&w=454&h=168)            

#### （3）fullscreenchange事件

​	在FullScreen API中，可以监听DOM对象或某个元素的fullscreenchange事件（当页面元素从非全屏显示状态变为全屏显示状态，或者反之，此时触发该事件）。在事件处理函数中，可以通过DOM对象的fullscreen属性值来判断页面或元素是否处于全屏显示状态。值为true时，代表处于全屏显示，为false代表不处于全屏显示。

#### （4）CSS样式

​	在CSS样式中，可以使用伪类选择器来单独指定全屏显示状态的页面或元素的样式。

​            ![img](https://qqadapt.qpic.cn/txdocpic/0/e484ba60ac70bea6cf7fa9df8b4bc671/0?_type=png&w=414&h=168)            

## 6.4 编辑相关API

### （1）Range对象

​	在HTML5中，一个Range对象代表页面上的一段连续区域。通过Range对象，可以获取或修改页面上的任何区域。

​	var range=document.createRange();

#### （1）Range对象的属性

##### （1）collapsed属性

​	布尔类型。用于判断Range对象所代表的区域的开始点与结束点是否处于相同位置，如果相同，则该属性值为true。

##### （2）commonAncestorContainer属性

​	节点类型。用于返回Range对象所代表的区域位于什么节点中，该属性值为包含了该区域的最底层节点，一个节点可能是一个元素，也可能是文字节点；

##### （3）startContainer属性

​	节点类型。用于返回Range对象所代表的区域的起点位于什么节点之中，该属性值为包含了该区域起点的最底层节点；

##### （4）endContainer属性

​	节点类型。用于返回Range对象所代表的区域的终点位于什么节点之中，该属性值包括了该区域终点的最底层节点。

##### （5）startOffset属性

​	整数值类型。用于返回Range对象所代表的区域的起点与包含该起点的节点与起点之间的距离

##### （6）endOffset属性

​	整数值类型。用于返回Range对象所代表的区域的终点位于与包含该终点的节点的起点之间的距离；

#### （2）Range对象的方法

##### （1）range.selectNode()

​	该方法用于将Range对象的起点指定为参数节点的起点，将Range对象的终点指定为参数节点的终点，使Range对象所代表的区域中包含该节点。该方法并不将该节点设定为高亮选取状态。

​	语法： rangeObj.selectNode(node);

​	参数：页面中的一个元素节点。

##### （2）range.selectNodeContents()

​	该方法用于将Range对象的起点指定为参数节点中所有内容的起点，将Range对象的终点指定为该节点中所有内容的终点，使range对象所代表的区域中包含该节点中的所有内容。

​	语法： rangeObj.selectNodeContents(node);

​	参数： 页面上的一个元素节点

##### （3）range.deleteContents()

​	该方法用于将Range对象中所包含的内容从页面中删除。

​	语法：rangeObj.deleteContents();

``` html
    <textarea id="txt" style="width: 500px; height: 250px;">111111111111111111111</textarea>
    <input type="button" value="清空内容" onclick="delContents(true);">
    <input type="button" value="删除文本域" onclick="delContents(false);">

    <script>
        function delContents(contents) {
            var textarea = document.querySelector("#txt");
            var range = document.createRange();
            if (contents) {
                range.selectNodeContents(textarea);
            } else {
                range.selectNode(textarea);
            }
            range.deleteContents();
        }
    </script>
```

##### （4）range.setSrart()

​	该方法用于将参数节点中的某个位置指定为Range对象所代表的区域的起点位置。

​	语法： rangeObj.setStart(node,offsetInsideNode);

​	参数： node：表示页面上的一个节点；

​		   offsetInsideNode: 整型数值；

​	描述： 当node为文字节点时，offsetInsideNode用于指定将第几个文字的结束位置作为Range对象所代表区域的起点位置；当node为包括其他子节点的节点时，offsetInsideNode用于指定将第几个子节点的结束位置指定为Range对象所代表的区域的起点位置。

##### （5）range.setEnd()

​	该方法用于将参数节点的某处位置指定为Range对象所代表的区域的结束位置。

​	语法： rangeObj.setEnd(node,offsetInsideNode);

​	参数： node：代表页面上的一个节点；

​		   offsetInsideNode： 整型数值。

​	描述：当node为文字节点时，offsetInsideNode用于指定将第几个文字的结束位置作为Range对象所代表区域的结束位置；当node为包括其他子节点的节点时，offsetInsideNode用于指定将第几个子节点的结束位置指定为Range对象所代表的区域的结束位置。

``` html
    <p id="p">这段文字的第三个到第十个文字将被删除</p> <input type="button" value="删除文字" onclick="delTxt();">

    <script>
        function delTxt() {
            var p = document.querySelector("#p");
            var textNode = p.firstChild;
            var range = document.createRange();
            range.setStart(textNode, 3);
            range.setEnd(textNode, 10);
            range.deleteContents();
        }
    </script>
```

##### （6）range.setStartBefore()

​	该方法用于将参数节点的起点位置指定为Range对象所代表区域的起点位置。

​	语法： rangeObj.setStartBefore(node);

​	参数： 代表页面上的一个节点；

##### （7）range.setStartAfter()

​	该方法用于将某个节点的重点位置指定为Range对象所代表区域的起点位置。

​	语法： rangeObj.setStartAfter(node);

​	参数： 代表页面的一个节点。

##### （8）range.setEndBefore()

​	该方法用于将某个节点的起点位置指定为Range对象所代表区域的重点位置；

​	语法： rangeObj.setEndBefore(node);

​	参数： 代表页面的一个节点；

##### （9）range.setEndAfter()

​	该方法用于将某个节点的终点位置指定为Range对象所代表区域的终点位置。

​	语法： rangeObj.setEndAfter(node);

​	参数：代表页面上的一个节点。

``` html
    <table id="table" border cellpadding=0 cellspacing=0 width=400 height=200 align="center">
        <caption>表格标题</caption>
        <thead>
            <tr>
                <th>表头1</th>
                <th>表头2</th>
                <th>表头3</th>
                <th>表头4</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>1</td>
                <td>2</td>
                <td>3</td>
                <td>4</td>
            </tr>
            <tr>
                <td>11</td>
                <td>22</td>
                <td>33</td>
                <td>44</td>
            </tr>
            <tr>
                <td>111</td>
                <td>222</td>
                <td>333</td>
                <td>444</td>
            </tr>
        </tbody>
    </table> <button type="button" onclick="delTable();">删除部分表格</button>
    <script>
        function delTable() {
            var
                table = document.querySelector("#table");
            if (table.rows.length > 0) {
                var row1 = table.rows[1];
                var row2 = table.rows[2];
                var range = document.createRange();
                range.setStartBefore(row1);
                range.setEndAfter(row2);
                range.deleteContents();
            }
        }
    </script>
```

##### （10）range.cloneRange()

​	该方法用于对当前Range对象进行复制。

​	语法： range.cloneRange();

​	无参数，返回值为复制的Range对象。

``` html
    <textarea id="txt">111111111111111111111</textarea> <button type="button" onclick="cloneRange();">克隆Range对象</button>

    <script>
        function cloneRange() {
            var range = document.createRange();
            var txt = document.querySelector("textarea");
            range.selectNodeContents(txt);
            var cloneRange = range.cloneRange();
            alert(cloneRange);
        }
    </script>
```

##### （11）range.cloneContents()

​	该方法用于在页面上追加一段HTML代码，并且将Range对象所代表区域的HTML代码克隆到被追加的HTML代码中。

​	语法： rangeObj.cloneContents();

​	无参数，返回一个documentFragment对象，该对象为一个容器元素，当需要追加、修改、删除或查找页面上的元素时将会变得非常有用。

``` html
    <div id="div1"> 示例对象 <br /> <button type="button" onclick="clone();">克隆</button> <br /> </div>
    <script>
        function clone() {
            var div1 = document.querySelector("#div1");
            var range = document.createRange();
            range.selectNodeContents(div1);
            var
                DocumentFragment = range.cloneContents();
            div1.appendChild(DocumentFragment);
        }
    </script>
```

##### （12）range.extractContents()

​	该方法用于将Range对象所代表区域的HTML代码克隆到一个DocumentFragment对象中，然后从页面删除这段被克隆的HTML代码。

​	语法： rangeObj.extractConents();

​	无参数，返回值为一个包含Range对象所代表区域中的HTML代码的DocumentFragment对象。

``` html
    <div id="div2" style="width: 400px;height: 100px; background: #ccc;color: green;"> 示例文字 </div>
    <div id="div3" style="width: 400px;height: 100px; background: #ddd;color: red;"></div> 
    <button type="button" onclick="changeTxt();">移动文字</button>
    <script>
        function changeTxt() {
            var div2 = document.querySelector("#div2");
            var div3 = document.querySelector("#div3");
            var range = document.createRange();
            range.selectNodeContents(div2);
            var Doc = range.extractContents();
            div3.appendChild(Doc);
        }
    </script>
```

##### （13）range.createContextualFragment()

​	该方法用于根据一段HTML代码创建一个DocumentFragment对象。

​	语法： rangeObj.createContextualFragment(htmlTxt);

​	参数： 代表一个HTML代码字符串。

​	返回值： 返回被创建的DocumentFragment对象。

``` html
    <div id="div4">示例文字</div>
    <button type="button" onclick="btn();">动态插入一个按钮</button>

    <script>
        function btn() {
            var htmlTxt = "<button type='button'>动态按钮</button>";
            var div4 = document.querySelector("#div4");
            var range = document.createRange();
            var Doc = range.createContextualFragment(htmlTxt);
            div4.insertBefore(Doc, div4.firstChild);
        }
    </script>
```

##### （14）range.insertNode()

​	该方法用于将参数节点插入到某个Range对象所代表的区域中，插入位置为Range对象所代表的区域的起点位置，如果该节点已存在于页面中，该节点将被移动到Range对象所代表的区域的起点处。

​	语法： rangeObj.insertNode(node);

​	参数： 一个节点；

``` html
    <div id="div5" onmouseup="insertNode();" style="width: 400px; height: 200px; background: #ccc;">
        该方法用于将指定的节点插入到某个Range对象所代表的区域中，插入位置为Range对象所代表的区域的起点位置。
     </div>
    <button type="button" id="btn2">按钮</button>
    <script>
        function insertNode() {
            var div5 = document.querySelector("#div5");
            var btn = document.querySelector("#btn2") var
                selection = document.getSelection();
            if (selection.rangeCount > 0) {
                rangeObj = selection.getRangeAt(0);
                rangeObj.insertNode(btn);
            }
        }
    </script>
```

##### （15）range.compareBoundaryPoints()

​	该方法用于比较两个Range对象的起点位置或终点位置。

​	语法： rangeObj.compareBoundaryPoints(type,rangeToCompare);

​	参数： type： 预定义的常量类型的整数值，用于指定将两个Range对象的起点位置进行比较还是将两个Range对象的终点位置进行比较；

​		   rangeToCompare: 为range对象，代表与RangeObj变量所引用的Range对象进行比较的Range对象。

​	返回值： 整型数值。返回值为-1时，代表第一个Range对象的指定比较位置在第二个Range对象的指定比较位置之前；返回值为0时，代表第一个Range对象的指定比较位置与第二个Range对象的指定比较位置相同；返回值为1时，代表第一个Range对象的指定比较位置在第二个Range对象的指定比较位置之后

type参数可指定的参数值表：

| **可指定的常量参数值** | **该常量的数值** | **描述**                                                     |
| ---------------------- | ---------------- | ------------------------------------------------------------ |
| Range.START_TO_START   | 0                | 将两个Range对象的起点位置进行比较                            |
| Range.START_TO_END     | 1                | 将第一个Range对象的起点位置与第二个Range对象的终点位置进行比较 |
| Range.END_TO_END       | 2                | 将第一个Range对象的终点位置与第二个Range对象的终点位置进行比较 |
| Range.END_TO_START     | 3                | 将两个Range对象的终点位置进行比较                            |

##### （16）range.compareNode()

​	该方法用于将一个Range对象所代表的区域与一个节点进行位置前后比较。

​	语法： rangeObj.compareNode(nodeToCompare);

​	参数： 用于进行位置比较的节点。

​	返回值： 该方法返回一个预定义常量类型的整数值，如下表：

| **可返回的常量值**          | **该常量的数值** | **描述**                          |
| --------------------------- | ---------------- | --------------------------------- |
| Range.NODE_BEFORE           | 0                | 节点在Range对象所代表的区域之前   |
| Range.NODE_AFTER            | 1                | 节点在Range对象所代表的区域之后   |
| Range.NODE_BEFORE_AND_AFTER | 2                | 节点中包含Range对象所代表的区域   |
| Range.NODE_INSIDE           | 3                | Range对象所代表的区域包含了节点。 |

例：		较位置与第二个Range对象的指定比较位置相同；<strong id="boldText">返回值为1时</strong>，代表第一个Range对象的指定比较位置在第二个Range对象的指定比较位置之后	

``` html
    <button type="button" onclick="compare();">比较选中字体与粗体的位置</button>
    <script>
        function compare() {
            var boldText = document.querySelector("#boldText");
            var selection = document.getSelection();
            if (selection.rangeCount > 0) {
                var rangeObj = selection.getRangeAt(0);
                var str = rangeObj.compareNode(boldText);
                switch (str) {
                    case Range.NODE_BEFORE:
                        alert("节点在Range对象所代表的区域之前");
                        break;
                    case Range.NODE_AFTER:
                        alert("节点在Range对象所代表的区域之后");
                        break;
                    case Range.NODE_BEFORE_AND_AFTER:
                        alert("节点中包含Range对象所代表的区域");
                        break;
                    case Range.NODE_INSIDE:
                        alert("Range对象所代表的区域包含了节点。");
                        break;
                }
            } else {
                alert("请选择一些文字！！");
            }
        }
    </script>
```

##### （17）range.intersectsNode()

​	该方法用于判断一个指定的节点与一个Range对象所包含的区域是否有重叠的部分。

​	语法： rangeObj.intersectsNode(nodeToCheck);

​	参数：代表用于判断的节点。

​	返回值： 布尔类型。当返回值为true时，代表指定节点与Range对象所包含的区域具有重叠的部分；返回值为false时，表示没有重叠部分。

##### （18）range.comparePoint()

​	该方法用于将一个指定位置与一个Range对象所代表的区域进行位置前后比较。

​	语法： rangeObj.comparePoint(nodeToCompare,offsetInsideNode);

​	参数： nodeToCompare：代表一个包含了指定位置的节点；

​		   offsetInsideNode: 整型值。用于指定第几个文字的结束位置作为比较位置，或者第几个子节点的结束位置用于比较位置。

​	返回值：整型数值。返回值为-1时，代表指定位置在Range对象的指定比较位置之前；返回值为0时，代表指定位置与Range对象的指定比较位置相同；返回值为1时，代表指定位置在Range对象的指定比较位置之后

##### （19）range.isPointInRange()

​	该方法用于判断一个指定的位置是否在一个Range对象所包含的区域之内。

​	语法： rangeObj.inPointInRange(nodeToCheck,offsetInsideNode);

​	参数： nodeToCheck： 代表用于判断的节点；

​		   offsetInsideNode:  整型值。用于指定第几个文字的结束位置作为比较位置，或者第几个子节点的结束位置用于比较位置。

​	返回值： 布尔类型。返回值为true时，代表指定位置在Range对象所包含的区域之内，放返回值为false时，代表指定位置不在Range对象所包含的区域之内。

##### （20）range.collapse()

​	该方法用于将Range对象所代表的区域的终点移动到该区域的起点处，或将Range对象所代表的区域的起点移动到终点处，使Range对象所代表的区域不包含任何内容。

​	语法： rangeObj.collapse(toStart);

​	参数： 布尔类型。当参数为true时，表示将Range对象所代表的区域的终点移动到该区域的起点处；当参数为false时，表示将Range对象所代表的区域的起点移动到终点处；

``` html
    <div id="div1" style="width: 400px; height: 200px; background: #ccc;">元素中的内容</div>
    <button type="button" onclick="good1();">选择元素</button>
    <button type="button" onclick="good2();">取消选择</button>
    <button type="button" onclick="good3();">显示Range内容</button>

    <script>
        var rangeObj = document.createRange();

        function good1() {
            var div1 = document.querySelector("#div1");
            rangeObj.selectNode(div1); //选中div中的内容 
        }

        function good2() {
            rangeObj.collapse(false); //清空range中的内容
        }

        function good3() {
            alert(rangeObj.toString());
        }
    </script>
```

##### （21）range.detach()

​	该方法用于从浏览器中释放Range对象。释放之后将不能再访问该Range对象，否则将抛出脚本错误。通常在必要的时候，我们应该注意释放不再需要使用的Range对象，以提高应用程序在运行时的性能。

​	语法： rangeObj.detach();

​	无参数，无返回值。

##### （22）range.toString()

​	该方法用于获取用户选取范围内的全部文字内容。

​	语法： rangeObj.toString();

### （2）Selection对象

#### **（1）selection对象的属性**

##### （1）anchorNode属性

​	节点属性类型。属性值为包含了用户选取内容的起点的最底层节点。

##### （2）anchorOffset属性

​	整型数值。属性值为用户选取内容的起点与anchorNode属性值所返回的节点的起点之间的距离。

##### （3）focusNode属性

​	节点类型。属性值为包含了用户选取内容的终点的最底层节点。

##### （4）focusOffset属性

​	整型数值。属性值为用户选取内容的终点与focusNode属性值返回的节点的终点之间的距离。

##### （5）isCollapsed属性

​	布尔值。当属性值为true时，表示用户选取内容的起点与终点位于相同位置。

##### （6）rangeCount属性

​	整型数值。属性值表示用户选取内容中包括多少个Range对象，每个Range对象代表用户选取范围中的一段连续区域。

#### （2）selection对象的方法

##### （1）selection.getRangeAt()

​	该方法用于获取Selection对象中的某个Range对象。

​	语法： selection.getRange(rangeIndex);

​	参数： 代表Range对象的序号。。在Chrome浏览器或者Safari浏览器中，由于用户每次只能选取一段区域，因此该参数值必须为0，否则抛出脚本错误。

##### （2）selection.removeRange()

​	该方法用于从Selection对象中移除一个指定的Range对象，该Range对象中所包含的内容将从高亮选取状态变为非选取状态。

​	语法： selection.removeRange(rangeToRemove);

​	参数： 代表要被移除的Range对象；

##### （3）selection.removeAllRanges()

​	该方法用于将用户当前选取的所有内容设定为非选取状态。

​	语法： selection.removeAllRanges();

​	无参数。

``` html
    <p>示例文字</p>
    <button type="button" id="btn1" onclick="remove();">取消选取内容</button>

    <script>
        function remove() {
            var selection = document.getSelection();
            selection.removeAllRanges();
        }
    </script>		
```

##### （4）selection.addRange()

​	该方法用于将一个Range对象添加到Selection对象中，该Range对象中所包含的内容将变为高亮状态。

​	语法： selection.addRange(rangeToAdd);

​	参数： 代表需要被添加到Selection对象中的Range对象。

``` html
    <p>该方法用于将一个<strong id="bold1">Range</strong>对象添加到<strong id="bold2">Selection</strong>对象中，该Range对象中所包含的内容将变为高亮状态。</p> 
    <button type="button" onclick="add();">添加选区</button>
    <script>
        function add() {
            var selection = document.getSelection();
            var boldText1 = document.querySelector("#bold1");
            var rangeObj1 = document.createRange();
            rangeObj1.selectNodeContents(boldText1);
            selection.removeAllRanges();
            selection.addRange(rangeObj1);
        }
    </script>
```

##### （5）selection.collapse()

​	该方法用于将用户当前选取范围的起点与终点均移动到一个指定位置，使用户选取范围内不包括任何内容。（即实现无法选中功能）

​	语法： selection.collapse(parentNode,offsetInsideParent);

​	参数： parentNode： 代表包含了指定位置的最底层节点。

​		   offsetInsideParent： 整型数值。用于指定第几个文字的结束位置或者第几个子节点的结束位置作为collapse方法所指定的位置。

``` html
    <div onmouseup="del();" style="width=100%; height: 80px; background: firebrick;">
        该方法用于将用户当前选取范围的起点与终点均移动到一个指定位置，使用户选取范围内不包括任何内容。
    </div>
    <script>
        function del() {
            var selection = document.getSelection();
            selection.collapse(selection.anchorNode, selection.anchorOffset);
        }
    </script>
```

##### （6）selection.collapseToStart()

​	该方法用于将用户当前选取范围的终点移动到起点处，使用户选取范围内不包括任何内容。（即使用户无法选中）

​	语法： selection.collapseToStart();

​	无参数，无返回值。

##### （7）selection.collapseToEnd()

​	该方法用于将用户当前选取范围的起点移动到终点处，使用户不能选取范围内不包括任何内容。（即使用户无法选中）

​	语法： selection.collapseToEnd();

​	无参数，无返回值。

##### （8）selection.deleteFromDocument()

​	该方法用于将用户选取的内容从页面删除。

​	语法： selection.deleteFromDocumnet();

​	无参数，无返回值。

``` html
    <div id="div6" onmouseup="deletee();">该方法用于将用户当前选取范围的起点与终点均移动到一个指定位置，使用户选取范围内不包括任何内容。</div>

    <script>
        function deletee() {
            var selection = document.getSelection();
            selection.deleteFromDocument();
        }
    </script>
```

##### （9）selection.extend()

​	该方法用于将用户选取范围的终点移动到指定位置。（即，实现选中补全）

​	语法： selection.extend(focusNode,focusOffset);

​	参数： focusNode： 代表指定位置所在的最底层节点；

​		   focusOffset： 整型数值。用于指定将第几个文字或者第几个子节点的结束位置作为用户选取范围的终点

``` html
    <div onmouseup="fanxiang();">选中补全</div>

    <script>
        function fanxiang() {
            var selection = document.getSelection();
            if (!selection.isCollapsed) {
                if (selection.focusNode.nodeType == Node.TEXT_NODE) {
                    var rangeObj = selection.getRangeAt(0); //反向选择时 
                    if (rangeObj.startContainer == selection.focusNode &&
                        rangeObj.startOffset == selection.focusOffset) {
                        selection.extend(selection.focusNode, 0);
                    } else { //正向选择时
                        selection.extend(selection.focusNode, selection.focusNode.textContent.length);
                    }
                }
            }
        }
    </script>
```

##### （10）selection.selectAllChildren()

​	该方法用于取消当前用户选取内容，并且选取某个指定元素中的全部子元素。（即，实现全选）

​	语法： selection.selectAllChildren(element);	

​	参数： 一个元素节点；

​	无返回值。

``` html
    <div id="myDiv">ssssssssssssssssssssssssssssssssss</div>

    <script>
        function select() {
            var myDiv = document.querySelector("#myDiv");
            var selection = document.getSelection();
            selection.selectAllChildren(myDiv);
        }
    </script>
```

##### （11）selection.toString()

​	该方法与Range对象的toString()方法类似，用于获取用户选取范围内的全部文字内容。

​	语法： selection.toString();

### （3）命令

#### （1）document.execCommand()

​	在HTML5中，通过运行页面或元素的execCommand方法来运行一条命令，每一条命令都将对用户通过鼠标所选取的内容执行一些操作。

​	大部分浏览器只能针对可编辑页面或可编辑元素中的用户通过鼠标选取的内容执行execCommand方法。在H5中可以通过contentEditable属性或者designMode属性，将元素或页面设置为可编辑页面。

​	语法： document.execCommand(commandIdentifier,userInterface,value);

​	参数： 第一个参数： 为一个大小写敏感的字符串，代表一个命令；

​		   第二个参数： 为一个布尔类型的参数，用于指定是否需要显示一个特定用户界面，当值为false时不需要显示一个特定用户界面，值为true时需要显示一个特定用户界面；（大部分情况下值都为false）

​		   第三个参数： 代表命令所使用的参数值。如果命令不使用参数值时，设置为null

​	返回值： 布尔值。返回值为false时，代表运行命令时发生了错误，返回为true时，代表命令成功运行。

``` html
    <div id="div1" contenteditable="true" onmouseup="autoBold();">
        在HTML5中，通过运行页面或元素的execCommand方法来运行一条命令，每一条命令都将对用户通过鼠标所选取的内容执行一些操作。
    </div>

    <script>
        function autoBold() {
            document.execCommand("bold", false, null);
        }
    </script>
```

#### （2）document.queryCommandSupported()

​	在H5中，该方法用于查询在当前浏览器中国是否能够运行某个命令。

​	语法： document.queryCommandSupported(commandIdentifier);

​	参数： 字符串，代表一个命令。

​	返回值： 布尔值，返回值为true时，代表在当前浏览器中能够运行该命令；返回false表示不能运行；

``` html
    <button type="button" onclick="test();">测试命令</button>

    <script>
        function test() {
            if (document.queryCommandSupported("myCommand")) {
                console.log("浏览器能够运行myCommand命令")
            } else {
                console.log("浏览器不能运行myCommand命令")
            }
            if (document.queryCommandSupported("bold")) {
                console.log("浏览器能够运行bold命令");
            } else {
                console.log("浏览器不能运行bold命令");
            }
        }
    </script>
```

例：		

#### （3）document.queryCommandState()

​	该方法用于判断当前命令的状态。

​	语法： document.queryCommandState(commandIdentifier);

​	参数： 字符串，代表一个命令；

​	返回值： 布尔值。当返回true时，代表命令的状态为true，当返回false时，代表该命令状态为false；

``` html
    <div id="div2" contenteditable="true">示例文字</div>
    <button type="button" onclick="setState();">测试命令状态</button>

    <script>
        function setState() {
            var state = document.queryCommandState("bold");
            switch (state) {
                case true:
                    alert("字体已经加粗");
                    break;
                case false:
                    alert("字体没有加粗");
                    break;
            }
            document.execCommand("bold");
        }
    </script>
```

#### （4）document.queryCommandIndeterm()

​	该方法用来判断一个命令是否处于无法确定状态。（例如当用户通过鼠标选取的文字中既有粗体文字，又有非粗体文字时，bold命令就处于无法确定状态）

​	语法： document.queryCommandIndeterm(commandIndentifier);

​	参数： 字符串，代表一个命令。

​	返回值： 布尔值。返回值为true时，代表该命令的状态无法确定。

#### （5）document.queryCommandEnabled()

​	在H5中，当用户用鼠标选取了可编辑页面或可编辑元素中的一段文字时，命令处于有效状态，当用户没有在页面中按下鼠标左键或使用鼠标选取了不可编辑页面或不可编辑元素的一段文字时，命令处于无效状态。当命令处于无效状态时，执行该命令将不会使页面发生变化。

​	该方法用于判断一个命令是否处于有效状态。

​	语法： document.queryCommandEnable(commandIdentifier);

​	参数： 字符串，代表一个命令。

​	返回值： 布尔值。返回值为true时，代表命令处于有效状态；返回值为false时，命令处于无效状态；

``` html
    <div id="div3" contenteditable="true">测试命令是否处于有效状态</div>
    <button type="button" onclick="setToBold();">测试</button>
    <script>
        function setToBold() {
            if (document.queryCommandEnabled("bold")) {
                console.log("命令处于有效状态");
            } else {
                console.log("命令处于无效状态");
            }
        }
    </script>		
```

#### （6）document.queryCommandValue()

​	该方法用于获取某个命令的命令值。

​	语法： document.queryCommandValue(commandIdentifier);

​	参数：字符串，代表一个命令。

​	返回值： 返回用户通过鼠标所选取内容的命令值。命令值的类型屈居于参数命令的类型。

``` html
    <div contenteditable="true"> <span style="color:red;">袁成成</span> <br> <span style="color:green;">aaaa</span> </div>
    <button type="button" onclick="getColor();">获取选取内容的颜色值</button>
    <div id="div7"></div>

    <script>
        function getColor() {
            var color = document.queryCommandValue("foreColor");
            var div7 = document.querySelector("#div7");
            div7.innerHTML = color;
        }
    </script>
```

### （4）命令表

​            ![img](https://qqadapt.qpic.cn/txdocpic/0/b00596159fe03d349fe401b7ac2363e7/0?_type=png&w=673&h=414)            

​            ![img](https://qqadapt.qpic.cn/txdocpic/0/2f1c13061b4ac0daa61bba2ddcb93ae4/0?_type=png&w=438&h=505)            

​            ![img](https://qqadapt.qpic.cn/txdocpic/0/4f70bc81fe05206d9200fca15b4b4ef6/0?_type=png&w=647&h=544)            

​            ![img](https://qqadapt.qpic.cn/txdocpic/0/8a2996c0eef65a39dbc847c6b322d5c1/0?_type=png&w=313&h=163)            



## 6.5 拖放及通知API

### （1）拖放API

#### （1）拖放的步骤

实现拖放的两个步骤：

1. 将想要被拖放的元素的draggable属性设为true，这样才能拖放该元素。（img、元素与a元素默认允许拖放）；
2. 编写拖放有关的事件处理代码；

| **事件名称** | **事件主体**         | **描述**                           |
| ------------ | -------------------- | ---------------------------------- |
| dragstart    | 被拖动元素           | 在开始拖放被拖放元素时触发         |
| drag         | 被拖动元素           | 在正在拖放被拖放元素时触发         |
| dragenter    | 拖放过程中经过的元素 | 在被拖放元素进入某元素时触发       |
| dragover     | 拖放过程中经过的元素 | 在被拖放元素在某元素内移动时触发   |
| dragleave    | 拖放过程中经过的元素 | 在被拖放元素移出目标元素时触发     |
| drop         | 目标元素             | 在目标元素完全接收被拖放元素时触发 |
| dragend      | 拖放的目标元素       | 在整个拖放操作结束时触发           |

##### （1）开始拖放

​	当开始拖放（即dragstart事件发生时），把要拖放的数据存入DataTransfer对象。

​	DataTransfer对象专门用来存储拖放时要携带的数据，可以被设置为拖动事件对象的dataTransfer属性。通过被拖动元素的dataTransfer属性的setData()方法，来实现数据的存储。

​	语法： ele.dataTransfer.setData(datatype,data);

​	参数： datatype：表示携带数据的数据种类的字符串。如“text/plain””text/html”。

​		  data：要携带的数据。如：任意字符串或this.innerHTML等；

datatype可选值如下表：

| **datatype**  | **描述**               |
| ------------- | ---------------------- |
| text/plain    | 文本文字               |
| text/html     | HTML文字               |
| text/xml      | XML文字                |
| text/uri-list | URL列表，每个URL为一行 |



##### （2）拖放过程

​	当被拖动（即drag事件发生时），目标元素接受到被拖放的元素后，目标元素执行getData()方法从DataTransfer对象获得数据。

​	语法： ele.dataTranfer.getdata(dataType);

​	参数： datatype：是setData()方法指定的数据类型；

​	注意：要实现拖放过程，还必须设定整个页面不执行默认处理，否则拖放不能实现。因为页面是先于其他元素接受拖放的，如果页面上拒绝拖放，那么页面上其他元素就都不能接受拖放了。

##### （3）拖放结束

​	当拖放结束（即dragend事件发生时），针对拖放的目标元素，必须在dragend和dragover事件内调用“事件对象.preventDefault()”，因为默认情况下，拖放的目标元素是不允许接受元素的。

##### （4）实例

``` html
 <body onload="jianting();">
        <h1>简单的拖动API</h1>
        <div id="source" style="width: 400px;height: 100px;" draggable="true">请拖动</div>
        <div id="text" style="width: 400px;height: 200px;border: 1px solid #000"></div>
 </body>
<script>
        function jianting() {
            var source = document.querySelector("#source");
            var text = document.querySelector("#text");
            document.ondragover = function (ev) {
                ev.preventDefault();
            }
            document.ondrop = function (ev) {
                ev.preventDefault();
            } 
            //(1)监听被拖动元素的拖动开始			
            source.addEventListener("dragstart", function (ev) {
                //向DataTransfer对象中添加拖动数据			
                var dt = ev.dataTransfer;
                dt.setData("text/plain", this.innerHTML);
            }, false)
            text.addEventListener("drop", function (ev) {
                var dt = ev.dataTransfer;
                txt = dt.getData("text/plain");
                text.textContent += txt;
                ev.preventDefault();
                ev.stopPropagation();
            }, false)
            text.addEventListener("dragend", function (ev) {
                ev.preventDefault();
            }, false)
        }
    </script>
```

#### （2）DataTransfer对象属性和方法

##### （1）effectAllowed属性

​	用来指定当元素被拖放时所允许的视觉效果。一般在ondragstart事件中设定。

​	可以指定的值为：none、copy、copyLink、copyMove、link、linkMore、move、all、unintialize；

| **属性值**  | **描述**                                                     |
| ----------- | ------------------------------------------------------------ |
| copy        | 允许将被拖动元素复制到拖动的目标元素中                       |
| move        | 允许将被拖动元素移动到拖动的目标元素中                       |
| link        | 通过拖放操作，被拖动元素会链接到拖动的目标元素上             |
| copyLink    | 被拖动元素被复制或链接到拖动的目标元素中，根据拖动的目标元素来决定执行复制操作还是链接操作。 |
| copyMove    | 被拖动元素被复制或移动到拖动的目标元素中，根据拖动的目标元素来决定执行复制操作还是移动操作 |
| linkMove    | 被拖动元素被链接或移动到拖动的目标元素中，根据拖动的目标元素来决定执行链接操作还是移动操作 |
| all         | 运行执行所有拖动操作（包括复制操作中、移动操作与链接操作）   |
| none        | 不允许执行任何拖动操作                                       |
| unintialize | 不指定effectAllowed属性值。这时将执行浏览器中默认允许的拖动操作，但该操作不能通过effectAllowed属性值来获取。 |

##### （2）dropEffect属性

​	表示拖放操作的视觉效果，运行设定其值，一般在ondragstart中设定。允许指定的值为none、copy、link、move；该该属性所表示的实际视觉效果必须与effectAllowed属性所表示的允许操作相匹配。

1. 如果effectAllowed属性设定为none，则不允许拖放元素；
2. 如果dropEffect属性设定为none，则不允许被拖放到目标元素中；
3. 如果effectAllowed属性设定为all或不设定，则dropEffect属性允许被设定为任何值；
4. 如果effectAllowed属性设定为具体操作，而dropEffect属性也设定了具体视觉效果，则dropEffect属性值必须与effectAllowed属性值相匹配。

##### （3）types属性

​	存入数据的种类 ，字符串的伪数组；

##### （4）dt.setData()

通过被拖动元素的dataTransfer属性的setData()方法，来实现数据的存储。

​	语法： ele.dataTransfer.setData(datatype,data);

​	参数： datatype：表示携带数据的数据种类的字符串。如“text/plain””text/html”。

​		  data：要携带的数据。如：任意字符串或this.innerHTML等；

datatype可选值如下表：

##### （5）dt.getData()

​	当被拖动（即drag事件发生时），目标元素接受到被拖放的元素后，目标元素执行getData()方法从DataTransfer对象获得数据。

​	语法： ele.dataTranfer.getdata(dataType);

​	参数： datatype：是setData()方法指定的数据类型；

##### （6）dt.clearData()

​	用于清除DataTransfer对象中存放的数据；

​	语法： dt.clearData(format);

​	参数： 指定的数据，如果省略此参数，则表示清除全部数据；

##### （7）dt.setDragImage()

​	用img元素来设置拖放图标。一般用在ondragstart事件中。

​	语法： dt.setDragImage(img,x,y);

​	参数： img： 设定为拖放图标的图标元素；

​		   x： 为拖放图标离鼠标指针的X轴方向的位移；

​		   y： 为拖放图标离鼠标指针的Y轴方向的位移量；

### （2）通知API

​	在H5中新增了通知API，该API允许在某个事件中向用户显示通知信息，无论用户正在查看哪个浏览器标签页中的内容。只要有一个浏览器标签页中接收到通知信息，浏览器中都将会显示。

#### （1）检查浏览器是否支持通知API

​	通过window对象的webkitNotifications属性值是否为NotificationCenter对象来判断浏览器是否支持通知API。

``` js
if(window.webkitNotifications) {    alert(“你的浏览器支持通知API”)；}else{alert(“你的浏览器不支持通知API”)；}
```

#### （2）向用户请求让浏览器显示通知的权限

##### （1）NC.requestPermission()

为了让浏览器可以显示通知，我们首先要向用户请求让浏览器显示通知的权限。

​	在通知API中，使用NotificationCenter对象的requestPermission()方法向用户请求让浏览器显示通知的权限。

​	语法： window.webkitNotifications.requestPermission();

​	无参数，无返回值。

​	注意：requestPermission()方法只在用户显式触发的事件（如单击、按下键盘上的某个键等）中有效。

##### （2）NC.checkPermission()

​	可以通过NotificationCenter对象的checkPermission()方法来判断用户是否给予让浏览器显示通知的权限。

​	语法： window.webkitNotifications.checkPermission();

​	无参数，返回值为0时代表已获得权限。

#### （3）创建通知

##### （1）NC.createNotification()

​	在已经获得让浏览器显示通知的权限后，可以通过NotificationCenter对象的createNotification()方法创建简单文本类型的通知。

​	语法： window.webkitNotifications.createNotification(img,title,text);

​	参数： img： 一副图片的URL地址，代表该通知被显示时所使用的图标来源；

​		   title： 字符串，代表通知标题；

​		   text： 字符串，代表通知内容；

​	返回值： Notification对象；

##### （2）NC.createHTMLNotification()

​	也可以通过NotificationCenter对象的createHTMLNotification()方法来创建一个HTML类型的通知；

​	语法： window.webkitNotifications.createHTMLNotification(url);

​	参数： URL地址，在显示通知时该URL地址中的内容将会作为通知内容被显示出来。

​	返回值： Notification对象

#### （4）显示通知

##### （1）Notification.show()

NotificationCenter对象的createNotification()方法和createHTMLNotification()方法均返回一个Notification对象，代表创建的通知，使用该对象的show()方法来显示通知。

​	语法： Notification.show();

##### （2）ondisplay事件

​	可以对Notification对象的ondisplay事件（当通知被显示时触发）进行监听并指定事件触发时所要执行的回调函数。

​	Notification.ondisplay=function(){}

##### （3）onclose事件

​	可以对Notification对象的onclose事件（当通知关闭时触发）进行监听并指定事件触发时所要执行的回调函数。

​	Notification.onclose=function(){}

``` html
    <button type="button" onclick="NotificationTest();">显示通知</button>
    <script>
        function createNotification(options) {
            if (options.type == "simple") {
                return window.webkitNotifications.createNotification("tianlongbabu.jpg", "天龙八部", "金庸");
            } else if (options.type = "html") {
                return window.webkitNotifications.createHTMLNotification(
                    "http://127.0.0.1:8848/%E6%B5%8B%E8%AF%95/10.%20%E6%8B%96%E5%8A%A8API.html");
            }
        }

        function NotificationTest() {
            if (window.webkitNotifications.checkPermission() == 0) {
                var Notification = createNotification({
                    type: "simple"
                });
                Notification.ondisplay = function () {
                    alert("通知被显示");
                }
                Notification.onclose = function () {
                    alert("通知被关闭");
                }
                Notification.show();
            } else {
                window.webkitNotifications.requestPermission();
            }
        }
    </script>
```

## 6.6 访问设备API

### （1）定位当前地理位置

HTML5通过Geolocation API来构建基于地理位置的应用。

Geolocation API通过**navigator.geolocation**全局对象进行访问。初次访问时，浏览器会询问用户是否允许共享位置，若用户允许，则程序获得使用Geolocation API的权限。

#### （1）判断浏览器支持度

判断浏览器是否支持Geolocation API可以通过判断是否存在navigator.geolocation对象得知。代码如下：

``` js
        if (navigator.geolocation) {
            //判断是否存在navigator对象				//获取地理位置		
        } else {
            alert('您的浏览器不支持Geolocation');
        }
```

#### （2）获取用户当前位置

​	通过navigator.geolocation的getCurrentPosition方法来获取用户当前位置。代码如下：

``` js
        navigator.geolocation.getCurrentPosition(
            function success(position) {},
            function error(positionError) {}, 
            options
        )
```

#### （3）实例--获取用户当前位置

``` js
        //建立成功回调函数
        function success(position) {
            console.log('获取位置成功：', position.coords); //输出用户坐标信息
        }
        //建立失败回调函数
        function error(positionError) {
            console.log('获取位置失败', positionError.code, positionError.message);
            //标识错误原因，相关错误信息描述。
        } //建立getCurrentPosition()方法的参数对象
        var options = {
            enableHighAccuracy: false,
            timeout: 30000,
            maximumAge: 0
        };
        //getCurrentPosition()方法的options参数用来设置以下内容           
        //（1）enableHighAccuracy：布尔值，是否获取高精度的位置信息，如果开启，可能会增加响应时间，默认为false。
        //（2）timeout：定位超时时间，单位毫秒，如果达到时间没有取得用户位置信息，则触发失败回调函数，默认为0，表示无限大；
        //（3）maximumAge：用户位置信息缓存的最大时间（单位毫秒），默认为0；
        navigator.geolocation.getCurrentPosition(success, error, options) //判断浏览器是否存在navigator.geolocation对象。
        if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(success, error, options);
        } else {
            alert('您的浏览器不支持Geolocation');
        }
```

#### （4）监听用户位置信息

​	当用户位置变化时，还可以通过navigator.geolocation全局对象的watchPosition()方法来监听用户坐标信息。该方法参数与getCurrentPosition()方法参数相同。

``` js
//监听用户位置信息	
    var watchId=navigator.geolocation.watchPosition(success,error,options);
```

#### （5）取消监听

``` js
//取消监听			
navigator.geolocation.clearWatch(watchId);
```

### （2）访问用户媒体设备

​	HTML5的getUserMedia API提供了访问用户媒体设备的能力，基于该特性，开发者可以在不依赖任何浏览器插件的条件下访问视频和音频等设备。

​	最新标准的getUserMedia API为**navigator.mediaDevices.getUserMedia**

​	新版getUserMedia语法如下：

``` js
	getUserMedia(constraints).then(successCallback).catch(errorCallback)
```

（1）参数constraints：

指定请求的媒体类型，主要包括video和audio

| 请求不带任何参数的视频与音频：{video:true,audio:true}        |
| ------------------------------------------------------------ |
| 指定视频分辨率：{video:{width: 640,height: 360}}             |
| 移动设备上，指定使用前置摄像头：{video:{facingMode:’user’}}  |
| 移动设备上使用后置摄像头：{video:{facingMode:{exact: ‘environment’}}} |

（2）参数successCallback：

​	成功回调函数successCallback的参数stream是MediaStream对象，表示媒体内容的数据流，可以通过URL.createObjectURL转换后设置为video或Audio元素的src属性来使用。

（3）参数errorCallback

​	失败的回调函数，它的参数error，包含属性name和message（即错误名称和错误信息），其中name属性值如下：

| **错误值**           | **错误名称** |
| -------------------- | ------------ |
| AbortError           | 中止错误     |
| NotAllowedError      | 拒绝错误     |
| NotFoundError        | 找不到错误   |
| NotReadableError     | 无法读取错误 |
| OverConstrainedError | 无法满足错误 |
| SecurityError        | 安全错误     |
| TypeError            | 类型错误     |

### （3）调用摄像头拍照实例

``` js
    <video id='video' autoplay style='width: 480px;height: 320px;'></video>
    <div><button id='capture'>拍照</button></div> <canvas id='canvas' width='480px' height='320px'></canvas>
    <script>
        //访问用户媒体设备的兼容办法
        function getUserMedia(constraints, success, error) {
            if (navigator.mediaDevices.getUserMedia) {
                //最新的标准API
                navigator.mediaDevices.getUserMedia(constraints).then(success).catch(error);
            } else if (navigator.webkitGetUserMedia) {
                //webkit核心浏览器		
                navigator.webkitGetUserMedia(constraints, success, error);
            } else if (navigator.mozGetUserMedia) {
                //Firefox	
                navigator.mozGetUserMedia(constraints, success, error);
            } else if (navigator.getUserMedia) {
                //旧版API				
                navigator.getUserMedia(constraints, success, error);
            }
        }
        var video = document.getElementById('video');
        var canvas = document.getElementById('canvas');
        var context = canvas.getContext('2d');
        //成功的回调函数
        function success(stream) { //兼容的webkit核心浏览器
            var CompatibleURL = window.URL || window.webkitURL
            //将视频流设置为video元素的源			
            video.src = CompatibleURL.createObjectURL(stream);
            video.play(); //播放视频			}		
            //异常的回调函数		
            function error(error) {
                console.log('访问用户媒体设备失败', error.name, error.message);
            }
            if (navigator.mediaDevices.getUserMedia || navigator.getUserMedia || navigator.webkitGetUserMedia ||
                navigator.mozGetUserMedia) {
                //调用用户媒体，访问摄像头
                getUserMedia({
                    video: {
                        width: 480,
                        height: 320
                    }
                }, success, error);
            } else {
                alert('您的浏览器不支持访问用户媒体设备');
            }
            //绑定拍照按钮的单击事件
            document.getElementById('capture').addEventListener('click', function () {
                context.drawImage(video, 0, 0, 480, 320); //将video画面在canvas上绘制出来	
            })
        }
    </script>
```

## 6.7 离线存储API

​	离线应用时HTML5新增功能，旨在帮助用户在没有网络的情况下也可以使用Web应用程序。HTML5离线功能包含离线资源缓存、在线状态监测、本地数据存储等方面。

1. **离线资源缓存：**通过浏览器机制将在线资源缓存到本地，当用户离线访问应用程序时，这些资源自动从本地加载，从而使用户可以正常使用应用程序。
2. **在线状态监测**：有些应用需要跟服务器做一些数据交互，应用开发者需要知道浏览器是否处于在线状态；
3. **本地数据存储：** 当程序处于离线状态时，程序需要把用户产生的数据存储到本地，以便在线时同步到服务器。

### （1）离线描述文件manifest

离线应用比普通Web应用多一个描述文件，该文件用来列出需要缓存和永不缓存的资源，以备离线时使用。

离线应用程序就是一个URL列表，在这个列表中包括HTML、CSS、JavaScript、图片及其他资源性文件的URL清单。当应用于服务器建立联系时，浏览器将在本地缓存所有的URL清单中的资源文件；当应用于服务器失去联系时，浏览器将调用缓存的文件来支撑Web应用。

Web应用之所以在离线时也可以正常访问，是由于H5的一种缓存机制CacheManifest，可以在线时将对应文件缓存在本地，离线时调用这些本地文件。而需要保存哪些文件，不需要保存哪些文件、在线与离线时需要调用哪些文件，这些都是由manifest文件来管理的。为了实现正常访问manifest文件，需要在服务器端进行相应的IIS配置；在使用manifest文件绑定页面后，浏览器与服务器进行数据交互。

1. #### manifest简介

为了在离线状态下继续访问Web应用，需要使用manifest文件将离线时需要缓存文件的URL写进该文件中，当浏览器与服务器建立联系后，浏览器就会根据manifest文件所列的缓存清单，将相应的资源文件缓存到本地。

所以创建文本文件的编辑器都可以新建manifest文件，保存时将扩展名改为“.manifest”

例如，一个完整的manifest文件如下：CACHE MANIFEST#version 0.0.0CACHE:#带相对路径的资源文件Js/Js0.jsCss/Css0.cssImages/img0.jpgImages/img1.jpgNETWORK:#列出在线时需要访问的资源文件Index.jspOnline.doFALLBack:#以成对形式列出不可访问文件的替补资源文件/Project/Index.jsp   /BkProject/Index.jsp

代码说明：

“CACHE:”标记表示离线时，浏览器需要缓存到本地的服务器资源文件列表，为某个页面编写manifest文件时，不需要将该页面放入到列表中，因为浏览器在进行本地资源缓存时，自动将这个页面进行了缓存。

“NETWORK：”表示在线时，需要访问的资源文件列表。这些文件只有在浏览器与服务器之间建立联系时才能访问。如果设置“*”，表示除了在“CACHE：”标记中标明需要缓存的文件之外，都不进行本地缓存。

“FALLBACK：”标记标明以成对方式列出不访问文件的替补文件。前者为不可访问的文件，后者为替补文件。即当前者文件不可访问时，浏览器会尝试访问后者文件。

**编写代码时注意：**

1. manifest文件第一行必须为：“CACHE MANIFEST”，表明这是一个通过浏览器将服务器资源进行本地缓存的格式文件；
2. 编写注释时要另起一行，并且用“#”开头；
3. Manifest类型文件内容允许重复编写分类标记，即可写多个：“CACHE：”标记或另外两种标记；
4. 如果没有找到分类标记，都视为“CACHE：”标记下的资源文件；
5. 建议通过注释的方式，标明每一个manifest类型文件的版本号，以便更新文件时使用；

创建完manifest类型文件后，就可以通过页面中`<html>`元素的manifest属性，将页面与manifest类型文件绑定起来。这样，浏览器在查看页面时，自动将manifest类型文件中所涉及到的资源文件缓存到本地。代码：


### （2）离线应用实例—随手记

``` html
    <h2>随手记</h2>
    <div> <textarea id="content" cols="100" rows="20"></textarea> </div>
    <script>
        //获取记录内容的文本域
        var el = document.getElementById('content');
        //blur事件：输入域失去焦点时触发监听文本域 
        el.addEventListener('blur', function () {
            //文本域失去焦点后，将文本域内容传给data
            var data = el.value;
            //如果是在线状态，就直接保存到服务器
            if (navigator.onLine) {
                saveOnline(data);
            } else {
                //如果是离线状态，则保存在本地
                localStorage.setItem('data', data)
            }
        });
        //监听上线事件
        window.online = function () { //从本地获取数据
            var data = localStorage.getItem('data');
            if (!!data) {
                //如果数据存在，则保存到服务器上
                saveOnline(data); //同时清空本地存储
                localStorage.removeItem('data');
            }
        };
        //保存内容的具体代码
        function saveOnline(data) {
            var xhr = new XMLHttpRequest();
            xhr.open('POST', '/savedata');
            xhr.send('data=' + data);
        }
    </script>
```

### （3）离线之后的资源更新—Service Worker

对于离线之后资源该如何更新，HTML5提供了另外一套API（**Service Worker**），帮助开发者完全控制离线数据，以支持更好的离线体验。

Service Worker主要提供4类功能：

1. 后台消息传递；
2. 网络代理；
3. 离线缓存；
4. 消息推送；

Service Worker是一段运行在浏览器后台进程的脚本，独立于当前页面，并且不会直接参与DOM操作。但是可以通过postMessage与页面通信，页面根据postMessage传递的信息与DOM进行互补。

### （4）IndexedDB

IndexedDB是一个事务性数据库系统，也是基于JavaScript的面向对象的数据库系统。IndexedDB为开发者在本地存储信息提供了可能。因为IndexedDB可以存储大量结构化的数据，并且使用基于索引的高效API检索。

## 6.8 数据存储API

​	HTML5中增加了两种全新的数据存储方式：Web Storage和Web SQL Database。前者可以用于临时或永久存储客户端的少量数据；后者是客户端本地化的一套数据库系统，通过这套系统可以将大量的数据保存在客户端，而无需与服务端交互，极大的减轻了服务端的压力，加快了其他页面浏览速度。

### （1）Web Storage存储简介

Web Storage API可以区分会话数据与长期数据，相应的API类型分为两种：sessionStorage（保存会话数据）和localStorage（在客户端长期保存数据），正是由于Web Storage API可以将客户端的数据分类进行存储，使它在应用上更加优于传统的、单一的Cookie方式；

#### （1）sessionStorage对象

​	在页面进行数据存储过程中，使用sessionStorage对象保存的数据时间非常短暂，因为该数据实质上是被保存在session对象中。用户在打开浏览器时，可以查看操作过程中要求临时保存的数据；一旦关闭浏览器，所有使用sessionStorage对象保存的数据将完全丢失。

​	sessionStorage保存数据的操作非常简单，只需要调用setItem()方法，调用格式如下：

​	sessionStorge.setItem(key,value);

key表示被保存内容的键名，value表示被保存内容的键值。在使用该方法保存数据时，对应的格式为（键名，键值）。一旦键名设置成功，则不允许修改，也不能重复；如果有重复的键名，那么只能修改对应的键值（即用新增重复的键名值取代原有重复的键名值）；

​	如果需要读取被保存的数据，应该调用sessionStorage对象中的getItem()方法，调用格式如下：

​	sessionStorage.getItem(key);

​	该方法将返回一个指定键名对应的键值，如果不存在则返回null值；

``` html
    <fieldset>
        <legend>sessionStorage对象保存与读取临时数据</legend> <input type="text" name="txtName" id="txtName" size="30px"
            onChange="txtName_change(this)" /> <input type="button" name="" id="" value="读取"
            onChange="btnGetValue_click();" />
        <p id="pStatus"></p>
    </fieldset>
    <script>
        function $$(id) {
            return document.getElementById(id);
        }

        function txtName_change(v) {
            var strName = v.value;
            sessionStorage.setItem("strName", strName); //存储数据；		
            $$("pStatus").style.display = "block";
            $$("pStatus").innerHTML = sessionStorage.getItem("strName"); //获取存储的数据；		
        }
        //单击读取按钮时调用的函数；		
        function btnGetValue_click() {
            $$("pStatus").style.display = "block";
            $$("pStatus").innerHTML = sessionStorage.getItem("strName");
        }
        //当重新打开浏览器sessionStorage对象存储的内容将会丢失；		
    </script>
```

#### （2）localStorage对象

​	使用localStorage对象可以将数据长期保存在客户端，直至人工清除为止。

​	localStorage对象保存数据内容需要调用setItem()方法，调用如下：

​	localStorage.setItem(key,value);

​	localStorage对象读取已存储的内容使用getItem()方法，调用格式：

​	localStorage.getItem(key);

​	localStorage对象可以将内容长期保存在客户端，即使是重新打开浏览器也不会丢失。如果需要清除localStorage对象保存的内容，可以调用removeItem()方法，调用格式如下：

​	localStorage.removeItem(key);

一旦删除成功，与键名对应的相应数据将全部删除。

注意：尽管使用localStorage对象可以将数据长期保存在客户端，但跨浏览器读取数据时，被保存的数据不可用。即每个浏览器只能读取各自浏览器中保存的数据，不能访问其他浏览器中保存的数据。

``` js
        function $$(id) {
            return document.getElementById(id);
        }

        function pageload() {
            //这个函数的作用：页面加载完成后获取之前的名称和密码，并赋值给对应的value值，使其显示出来。		
            var strName = localStorage.getItem("keyName"); //读取存储的数据			
            var strPass = localStorage.getItem("keyPass");
            if (strName) {
                $$("txtName").value = strName;
            }
            if (strPass) {
                $$("txtPass").value = strPass;
            }
        }

        function btnLogin_click() {
            //这个函数的作用：判断用户是否勾选保存密码这一项。			
            var strName = $$("txtName").value;
            var strPass = $$("txtPass").value;
            localStorage.setItem("keyName", strName);
            if ($$("chkSave").checked) {
                localStorage.setItem("keyPass", strPass);
            } else {
                localStorage.removeItem("keyPass");
            }
            $$("spnStatus").className = "status";
            $$("spnStatus").innerHTML = "登录成功！";
        }
```

### （2）localStorage详解

#### （1）清空localStorage数据

当保存的数据很多时，使用removeItem();的方法逐条删除相对麻烦，此时可以调用localStorage对象中的另一个方法clear()，该方法的功能是清空全部localStorage对象保存的数据，调用如下：

localStorage.clear();

该方法无参数，表示晴空全部的数据。一旦使用localStorage对象保存了数据，用户就可以在浏览器中打开相应的代码调试工具，查看每条数据对应的键名和键值。执行删除或清空操作之后，对应的数据也会发生变化，这些变化可以通过浏览器的代码调试工具进行侦测。

``` js
        function btnDel_click() {
            localStorage.clear(); //清除数据时直接调用即可；		
            $$("pStatus").style.display = "block";
            $$("pStatus").innerHTML = "已完全清除数据！"
        }
```

#### （2）遍历localStorage数据

为了查看localStorage对象保存的全部数据信息，通常要遍历这些数据，在遍历过程中需要访问localStorage对象的另外两个属性：length和key。前者表示localStorage对象中保存的数据总量；后者表示保存数据时的键名项，该属性常与索引号（index）配合使用，表示第几条键名对应的数据记录。其中，索引号（index）以0值开始，如果取第三条键名对应的数据，index应该为2；

#### （3）使用JSON对象存取数据

虽然使用“，”的方式可以存储更多的键值内容，但处理相对复杂，拓展性差，数据结构不合理，只能应对少量数据。在H5中可以通过localStorage数据与JSON对象的转换，快速实现存储更多数据的功能。

如果将localStorage数据转换成JSON对象，需要调用JSON对象的parse()方法，调用格式如下：JSON.parse(data);参数data表示localStorage对象获取的数据，调用该方法将返回一个装载data数据的JSON对象。。除此之外，还可以通过stringify()方法，将一个实体对象转换为JSON格式的文本数据，调用格式如下：JSON.stringify(obj);参数obj表示任意的实体对象，调用该方法将返回一个由实体对象转成JSON格式的文本数据集；

``` js
var strTxtData=JSON.stringify(SetData);//键值			
localStorage.setItem(strStuId,strTxtData);//存储数据				  
var GetData=JSON.parse(localStorage.getItem(strKey));
```

#### （4）管理localStorage数据

引入JSON对象，先将保存数据转换成JSON对象，再通过对象读取数据，极大的方便使用localStorage对象保存多个字段数据的操作；此外还可以通过键名、查询、更新、删除对应的键值记录，真正实现对localStorage对象保存数据的管理功能。

### （3）Web SQL数据库基础

Web Storage存储本地数据的方法目前在主流的浏览器中可以实现，相关的API已经标准化，但是Web Storage存储的空间有限（只有5MB），容量太小。而Web SQL数据库，它内置SQLite数据库，对数据库的操作，可以通过调用executeSql()方法实现，允许JavaScript代码控制数据库的操作。

#### （1）打开和创建数据库（openDatabase）

WebDB可以实现数据的本地存储，它提供了关系数据库的基本功能，可以存储页面中交互的、复杂的数据；它既可以保存数据也可以缓存从服务器获取的数据。WebDB通过事务驱动，实现对数据的管理，因此它支持多浏览器的并发操作，而不发生存储时的冲突。

如果要通过WebDB进行本地数据的存储，首先需要打开或创建一个数据库，打开或创建数据库的API是openDatabase，调用方法如下：

openDatabase(DBName,DBVersion,DBDescribe,DBSize,Callback());

DBName表示数据库的名称；DBVersion表示版本号（目前版本号为“1.0”，写死就可以）；DBDescribe表示对数据库的描述；DBSize表示数据库的大小，单位是字节（写法：2MB需要写作：2*1024*1024）；Callback()表示创建或打开数据库成功后执行的一个回调函数（可省略不写）。

调用该方法时，如果指定的数据库名存在，则打开该数据库；否则新创建一个指定名称的空数据库。

``` js
        function $$(id) {
            return document.getElementById(id);
        }
        var db;

        function btnCreateDB_click() {
            //点击创建数据库按钮时调用			
            db = openDatabase('student', '1.0', 'stuManage', 2 * 1024 * 1024, function () {
                $$("pStatus").style.display = "block";
                $$("pStatus").innerHTML = "数据库创建成功！";
            });
        }

        function btnTestConn_click() { //点击测试连接按钮时调用		
            if (db) {
                $$("pStatus").style.display = "block";
                $$("pStatus").innerHTML = "数据库创建成功！";
            }
        }
```

#### （2）执行事务（transaction）

当打开/创建数据库后，就可以使用数据库对象中的transaction方法执行事务处理。每一个事务处理请求都作为数据库的独立操作，这有效避免在处理事务时发生冲突。调用格式：

transaction(TransCallback,ErrorCallback,SuccessCallback);

参数TransCallback表示事务回调函数，可以写入需要执行的SQL语句；参数ErrorCallback表示执行SQL语句出错时的回调函数；参数SuccessCallback表示执行SQL语句成功时的回调函数；

``` js
        var db;

        function btnCreateTrans_click() {
            db = openDatabase('Student', '1.0', 'StuManage', 2 * 1024 * 1024);
            if (db) {
                var strSQL = "create table if not exists StuInfo"; //这句SQL语句的功能是：如果不存在，则新建一个名为StuInfo的表		
                strSQL += "(StuId unique,Name text ,Sex text,Score int)";
                //这个表包含4个字段，分别为StuID、Name、Sex、Score。其中StuId为主键，不允许重复，字段Score为int类型，字段Name和Sex为字符型；		
                db.transaction(function (tx) {
                    tx.executeSql(
                        strSQL); //执行对应的SQL语句。				
                }, function () {
                    Status_Handle("事务执行出错！"); //执行SQL语句失败时的回调函数			
                }, function () {
                    Status_Handle("事务执行成功！"); //执行SQL语句成功时的回调函数				
                })
            }
        }

        function Status_Handle(message) {
            $$("pStatus").style.display = "block";
            $$("pStatus").innerHTML = message;
        }
```

注意：在执行SQL语句中，“if not exists”表示“如果该表不存在”。在新增表时常常需要添加该语句，以避免增加重名的表；

#### （3）插入数据（executeSql）

通过事务处理的方式可以执行SQL语句创建新表，那么想要给新表插入数据也可以通过执行相应的SQL语句来实现。实现的关键除了调用事务方法外，还要调用一个执行SQL语句的方法executeSql，调用格式如下：

executeSql(strSQL,[Arguments],SuccessCallback,ErrorCallback);

strSQL表示需要执行的SQL语句（必选），Arguments表示语句需要的实参（可选），SuccessCallback表示SQL语句执行成功时的回调函数（可选），ErrorCallback表示SQL语句执行出错时的回调函数（可选）。

在使用executeSql方法执行SQL语句时，允许使用？作为语句中的形参，与形参相对应的实参放置在第二个参数Arguments中（例如：executeSql(“insert into StuInfo value(?,?,?,?)”,[“1234”,”张三”,”男”,”0”],,）;  ？形参的数量必须与对应的实参完全一致，如果SQL语句中没有？形参，第二个参数Arguments中不允许有任何内容出错，否则执行SQL语句时将会报错。

#### （4）数据管理

只要符合规范的SQL语句都可以通过executeSql()方法执行，例如“select”、“updata”、“delete”组成的SQL语句，都可以带？形参，通过executeSql方法执行

## 6.9 文件相关API

``` html
<input type="file" multiple=true ></p>  <!-- 添加multiple=true属性之后，可以选择上传多个文件 -->
```

### （1）选择文件

#### （1）使用Blob接口获取文件的类型和大小

Blob表示二进制数据块，Blob接口提供了一个slice方法，通过该方法可以访问指定长度与类型的字节内部数据块。该接口提供两个属性：一个为“size”，表示返回数据块的大小；一个为“type”表示返回数据块的MIME类型，如果不能确定数据块的类型，则返回一个空字符串。

``` html
    <form action="">
        <fieldset>
            <legend>上传多个文件：</legend> <input type="file" multiple=true onChange="fileUpload_GetFileList(this.files);"
                id="fleUpload">
            <ul id="ulUpload"></ul>
        </fieldset>
    </form>
    <script>
        function $$(id) {
            return document.getElementById(id);
        } // 选择上传文件时调用的函数	
        function fileUpload_GetFileList(f) {
            var strLi = "<li class='li'>";
            strLi = strLi + "<span>文件名称</span>";
            strLi = strLi + "<span>文件类型</span>";
            strLi = strLi + "<span>文件大小</span>";
            strLi = strLi + "</li>";
            for (var intI = 0; intI < f.length; intI++) {
                var tmpFile = f[intI];
                strLi = strLi + "<li>";
                strLi = strLi + "<span>" + tmpFile.name + "</span>";
                strLi = strLi + "<span>" + tmpFile.type + "</span>";
                strLi = strLi + "<span>" + tmpFile.size + "KB</span>";
                strLi = strLi + "</li>";
            }
            $$("ulUpload").innerHTML = strLi;
        }
    </script>
```

#### （2）通过类型过滤选择文件

通过file对象可以获取每个上传文件的名称、类型、大小，根据这个特征，可以过滤上传文件的类型。具体流程：当选择上传文件后，遍历每一个file对象，获取该对象的类型，并将该对象与设置的过滤类型进行匹配；如果不符合，则提示上传文件类型出错，或拒绝上传，从而实现选择文件时过滤掉不需要上传的文件。

``` html
    <form action="">
        <fieldset>
            <legend>通过类型过滤选择的文件：</legend> <input type="file" name="fileUpload" id="fileUpload"
                onChange="fileUpload_CheckType(this.files);" multiple=true>
            <p id="pTip"></p>
        </fieldset>
    </form>
    <script>
        function $$(id) {
            return document.getElementById(id);
        }

        function fileUpload_CheckType(f) {
            var strP = "",
                strN = "",
                intJ = 0;
            var strFileType = "/image*/"; // 表示所有的图片类型		
            for (var intI = 0; intI < f.length; intI++) {
                var tmpFile = f[intI];
                if (!tmpFile.type.match(strFileType)) {
                    intJ = intJ + 1;
                    strN = strN + tmpFile.name + "<br>";
                }
            }
            strP = "检测到（" + intJ + "）个非图片格式文件";
            if (intJ > 0) {
                strP = strP + "文件名如下：<p>" + strN + "</p>"
            }
            $$("pTip").innerHTML = strP;
        }
    </script>
```

#### （3）通过accept属性过滤选择文件类型

​	在file类型的<input>元素中，设置accept属性值后，在打开窗口选择文件时，默认的文件类型就是所设置的过滤类型；（在目前浏览器中，该方法还不是很有效）

``` html
    <form action="">
        <fieldset>
            <legend>设置accept属性过滤选择文件类型：</legend> 
            <input type="file" accept="image/gif">
        </fieldset>
    </form>
```

### （2）使用FileReader接口读取文件

​	读取或浏览文件需要通过fileReader接口。该接口不仅可以读取图片文件，还可以读取文本或二进制文件。同时根据该接口提供的事件与方法，可以动态侦查文件读取时的详细状态；

#### （1）FileReader接口方法

​	FileReader接口提供了一个异步的API，通过这个API可以从浏览器主线程中异步访问文件系统中的数据。因此FileReader接口可以读取文件中的数据，并将读取的数据放入内存中。

​	当访问不同文件时，必须重新调用FileReader接口的构造函数。因为每调用一次FileReader接口都将返回一个新的FileReader对象，只有这样才能访问不同的文件数据。

​	在FileReader中拥有许多常用的方法，用于读取文件或响应事件，如onabort事件触发时需要调用abort()方法。

Filereader接口的常用方法：

| 方法名称             | 参数 | 功能描述                                      | 使用说明                                                     |
| -------------------- | ---- | --------------------------------------------- | ------------------------------------------------------------ |
| readAsBinaryString() | file | 以二进制的方式读取文件内容                    | 使用该方法时，将file对象返回的数据块，作为一个二进制字符串的形式，分块读入内存中。 |
| readAsArrayBuffer()  | file | 以数组缓冲的方式读取文件内容                  | 调用该方法时，将file对象返回的数据字节数以数组缓存的方式读入内存中。 |
| readAsdataURL()      | file | 以数据URL的方式读取文件内容（读取图片地址等） | 调用该方法时，将file对象返回的数据块，以一串数据URL字符的形式展示在页面中，这种方法一般读取数据块较小的文件。 |
| readAsText()         | file | 以文本编码的方式读取文件内容（读取文本）      | 调用该方法时，其中encoding参数表示文本文件编码方式，默认值为utf-8，即以utf-8编码格式将获取数据块按文本方式读入内存中。 |
| abort()              | file | 读取数据中止时，将自动触发该方法              | 如果在读取文件数据过程中出现异常或错误时，触发该方法，返回错误代码信息。 |

##### （1）使用readAsDataURL()预览图片

​	通过FileReader接口中的readAsDataURL()方法，可以获取API异步读取的文件数据，另存为数据URL；将该URL绑定<img>元素的src属性值，即可实现图片文件预览效果；

``` html
    <form action="">
        <fieldset>
            <legend>预览图片文件：</legend> <input type="file" id="fleUpload" onChange="fileUpload_PrevImageFile(this.files);"
                multiple=true>
            <ul id="ulUpload"></ul>
        </fieldset>
    </form>
    <script>
        function $$(id) {
            return document.getElementById(id);
        }

        function fileUpload_PrevImageFile(f) { //检测浏览器是否支持FileReader对象			
            if (typeof FileReader == 'undefined') {
                alert("检测到您的浏览器不支持FileReader对象");
            }
            var strHTML = "";
            for (var intI = 0; intI < f.length; intI++) {
                var tmpFile = f[intI];
                var reader = new FileReader();
                reader.readAsDataURL(tmpFile); // 引入FileReader接口提供的读取文件的方法
                readAsDataURL
                () //每次读取文件前都要重构一个新的FileReader对象，将每个文件以数据URL的方式读入页面。读取成功时触发onload事件，通过result属性获取文件读入页面中的URL地址，将该地址与img元素进行绑定即可；		
                reader.onload = function (e) {
                    strHTML = strHTML + "<span>";
                    strHTML = strHTML + "<img src='" + e.target.result + "'alt=''/>";
                    strHTML = strHTML + "</span>";
                    $$("ulUpload").innerHTML = "<li>" + strHTML + "</li>";
                }
            }
        }
    </script>
```

##### （2）使用readAsText()方法读取文本文件

实现方法与读取图片基本相似；

``` html
    <form>
        <fieldset>
            <legend>读取文本文件：</legend> <input type="file" name="my_name" multiple="true" id="fleUpload"
                onChange="fleUpload_ReadTxtFile(this.files);">
            <article id="artShow"></article>
        </fieldset>
    </form>
    <script>
        function $$(id) {
            return document.getElementById(id);
        }

        function fleUpload_ReadTxtFile(f) { //检测浏览器是否支持FileReader对象；	
            if (typeof FileReader == "undefined") {
                alert("检测到您的浏览器不支持FileReader对象");
            }
            var tmpFile = f[0];
            var reader = new FileReader();
            reader.readAsText(tmpFile);
            reader.onload = function () {
                $$("artShow").innerHTML = "<pre>" + e.target.result + "</pre>";
            }
        }
    </script>
```

#### （2）侦听FileReader接口中的事件

在FileReader接口中，提供了很多常用的事件，以及一套完整的事件处理机制。通过一些事件的触发可以清晰的侦听FileReader对象读取文件的详细过程，以便更加精确的定位每次读取文件时的事件顺序，为编写事件代码提供有力支持。

FileReader接口常用事件：

| 事件名称    | 描述                                               |
| ----------- | -------------------------------------------------- |
| onloadstart | 当读取数据开始时，触发该事件                       |
| onprogress  | 当正在读取数据时，触发该事件                       |
| onabort     | 当读取数据中止时，触发该事件                       |
| onerror     | 当读取数据失败时，触发该事件                       |
| onload      | 当读取数据成功时，触发该事件                       |
| onloadend   | 当请求操作成功时，无论操作是否成功都将触发该事件。 |

一个文件通过FileReader接口中的方法正常读取时，触发事件的先后顺序为：onloadstart--onprogress--onload--onloadend；

大部分文件的读取过程都集中在onprogress事件中，该事件耗时最长；

如果文件读取过程中出现异常或中止，那么onprogress事件将结束，直接触发onerror或onabort事件，不会触发onload事件；

Onload事件是文件读取成功时触发，而onloadend事件虽然也是文件读取成功时触发，但该事件无论文件读取是否成功，都将触发。因此，想要正确获取文件，必须在onload事件中编写代码

### （3）使用DataTransfer对象拖放上传图片文件

在H5中，借助DataTransfer对象中提供的方法，可以实现浏览器与其他应用程序之间文件的拖动。

### （4）文件读取时的错误与异常

虽然使用FileReader接口中的方法可以快速实现各类文件的读取。但在文件读取的过程中，不可避免的会出现各类型的错误与异常；通过FileError对象可以获取这些错误与异常所产生的错误代码，根据返回的错误代码，可以分析具体发生错误与异常的原因。

#### （1）错误与异常发生的条件

在使用FileReader接口中的API异步访问文件数据的过程中，出现下列情况，可能会出现潜在的错误与异常：

1. 文件被移动或删除或被其他应用程序并发式修改。
2. 权限原因，无法读取文件的数据信息；
3. 文件出于安全因素的考虑，读取文件时，返回一个无效的数据信息；
4. 读取文件太大，超出URL网址的限制，无法返回有效的数据结构信息；
5. 读取文件过程中，应用程序本身触发了中止读取文件的abort()事件。

在使用FileReader接口读取文件过程中，一旦出现错误与异常，无法返回文件数据时，可以使用FileError接口。该接口主要用于异步报告错误。

``` js
reader.onerror=function (e) {       // 出现错误与异常时才执行，返回错误代码；       Alert(“FileError:”+e.target.error.code);}
```

#### （2）错误代码说明

FileError对象获取的错误代码及说明：

| 错误常数         | 说明                               |
| ---------------- | ---------------------------------- |
| NOT_FOUND_ERR    | 文件无法找到或原文件已被修改       |
| SECURITY_ERR     | 出于安全考虑，无法获取数据文件     |
| ABORT_ERR        | 触发abort事件，中止文件读取过程    |
| NOT_READABLE_ERR | 由于权限问题，不能获取数据文件     |
| ENCODING_ERR     | 读取文件太大，超出读取时地址的限制 |

文件在读取过程中，如果出现错误与异常，可以在onerror事件中，通过e.target.error.code方式捕获异常的错误代码。而获取的错误代码就是如表所示的错误常数，用户可根据返回错误代码的不同，分别进行后续代码的处理与修改。